// Code generated by re2go 4.3 on Mon Jul  7 14:23:43 2025, DO NOT EDIT.
package parser

import (
    "bytes"
    "fmt"
    "encoding/hex"

    "github.com/cedar-policy/cedar-go/internal/schema/token"
)

func (l *Lexer) lex() (pos token.Position, tok token.Type, lit string, err error) {
    for {
        lit = ""
        l.pos.Offset = l.cursor
        l.pos.Column = l.cursor - l.lineStart + 1
        l.token = l.cursor
        pos = l.pos

        
{
	var yych byte
	yych = l.input[l.cursor]
	switch (yych) {
	case 0x00:
		goto yy1
	case '\t':
		fallthrough
	case ' ':
		goto yy4
	case '\n':
		goto yy5
	case '\r':
		goto yy6
	case '"':
		goto yy7
	case ',':
		goto yy8
	case '/':
		goto yy9
	case ':':
		goto yy10
	case ';':
		goto yy11
	case '<':
		goto yy12
	case '=':
		goto yy13
	case '>':
		goto yy14
	case '?':
		goto yy15
	case 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
		fallthrough
	case '_':
		fallthrough
	case 'b':
		fallthrough
	case 'd':
		fallthrough
	case 'f','g','h':
		fallthrough
	case 'j','k','l','m':
		fallthrough
	case 'o':
		fallthrough
	case 'q':
		fallthrough
	case 's':
		fallthrough
	case 'u','v','w','x','y','z':
		goto yy16
	case '[':
		goto yy19
	case ']':
		goto yy20
	case 'a':
		goto yy21
	case 'c':
		goto yy22
	case 'e':
		goto yy23
	case 'i':
		goto yy24
	case 'n':
		goto yy25
	case 'p':
		goto yy26
	case 'r':
		goto yy27
	case 't':
		goto yy28
	case '{':
		goto yy29
	case '}':
		goto yy30
	default:
		goto yy2
	}
yy1:
	l.cursor += 1
	{ l.cursor -= 1; tok = token.EOF; return }
yy2:
	l.cursor += 1
yy3:
	{ err = ErrUnrecognizedToken; return }
yy4:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '\t') {
		goto yy4
	}
	if (yych == ' ') {
		goto yy4
	}
	{
            continue
        }
yy5:
	l.cursor += 1
	{
            l.pos.Line += 1
            l.pos.Column = 1
            l.lineStart = l.cursor
            continue
        }
yy6:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '\n') {
		goto yy5
	}
	goto yy3
yy7:
	l.cursor += 1
	{ return l.lexString('"') }
yy8:
	l.cursor += 1
	{ tok = token.COMMA; lit = ","; return }
yy9:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '/') {
		goto yy31
	}
	goto yy3
yy10:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == ':') {
		goto yy33
	}
	{ tok = token.COLON; lit = ":"; return }
yy11:
	l.cursor += 1
	{ tok = token.SEMICOLON; lit = ";"; return }
yy12:
	l.cursor += 1
	{ tok = token.LEFTANGLE; lit = "<"; return }
yy13:
	l.cursor += 1
	{ tok = token.EQUALS; lit = "="; return }
yy14:
	l.cursor += 1
	{ tok = token.RIGHTANGLE; lit = ">"; return }
yy15:
	l.cursor += 1
	{ tok = token.QUESTION; lit = "?"; return }
yy16:
	l.cursor += 1
	yych = l.input[l.cursor]
yy17:
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy18
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy18
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy18:
	{ tok = token.IDENT; lit = l.literal(); return }
yy19:
	l.cursor += 1
	{ tok = token.LEFTBRACKET; lit = "["; return }
yy20:
	l.cursor += 1
	{ tok = token.RIGHTBRACKET; lit = "]"; return }
yy21:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy34
	}
	if (yych == 'p') {
		goto yy35
	}
	goto yy17
yy22:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy36
	}
	goto yy17
yy23:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy37
	}
	goto yy17
yy24:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy38
	}
	goto yy17
yy25:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy40
	}
	goto yy17
yy26:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'r') {
		goto yy41
	}
	goto yy17
yy27:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy42
	}
	goto yy17
yy28:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy43
	}
	if (yych == 'y') {
		goto yy44
	}
	goto yy17
yy29:
	l.cursor += 1
	{ tok = token.LEFTBRACE; lit = "{"; return }
yy30:
	l.cursor += 1
	{ tok = token.RIGHTBRACE; lit = "}"; return }
yy31:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '\n') {
		if (yych <= 0x00) {
			goto yy32
		}
		if (yych <= '\t') {
			goto yy31
		}
	} else {
		if (yych != '\r') {
			goto yy31
		}
	}
yy32:
	{ tok = token.COMMENT; lit = l.literal(); return }
yy33:
	l.cursor += 1
	{ tok = token.DOUBLECOLON; lit = "::"; return }
yy34:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy45
	}
	goto yy17
yy35:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy46
	}
	goto yy17
yy36:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy47
	}
	goto yy17
yy37:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 's') {
		goto yy17
	}
	if (yych <= 't') {
		goto yy48
	}
	if (yych <= 'u') {
		goto yy49
	}
	goto yy17
yy38:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy39
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy39
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy39:
	{ tok = token.IN; lit = "in"; return }
yy40:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'm') {
		goto yy50
	}
	goto yy17
yy41:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy51
	}
	goto yy17
yy42:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy52
	}
	goto yy17
yy43:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'g') {
		goto yy53
	}
	goto yy17
yy44:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy54
	}
	goto yy17
yy45:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy55
	}
	goto yy17
yy46:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'l') {
		goto yy56
	}
	goto yy17
yy47:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy57
	}
	goto yy17
yy48:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy58
	}
	goto yy17
yy49:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'm') {
		goto yy59
	}
	goto yy17
yy50:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy61
	}
	goto yy17
yy51:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy62
	}
	goto yy17
yy52:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy63
	}
	goto yy17
yy53:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy64
	}
	goto yy17
yy54:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy66
	}
	goto yy17
yy55:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy68
	}
	goto yy17
yy56:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy69
	}
	goto yy17
yy57:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy70
	}
	goto yy17
yy58:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy71
	}
	goto yy17
yy59:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy60
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy60
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy60:
	{ tok = token.ENUM; lit = "enum"; return }
yy61:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy72
	}
	goto yy17
yy62:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy73
	}
	goto yy17
yy63:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'u') {
		goto yy74
	}
	goto yy17
yy64:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy65
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy65
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy65:
	{ tok = token.TAGS; lit = "tags"; return }
yy66:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy67
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy67
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy67:
	{ tok = token.TYPE; lit = "type"; return }
yy68:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy75
	}
	goto yy17
yy69:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy77
	}
	goto yy17
yy70:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'x') {
		goto yy78
	}
	goto yy17
yy71:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'y') {
		goto yy79
	}
	goto yy17
yy72:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy81
	}
	goto yy17
yy73:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy82
	}
	goto yy17
yy74:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'r') {
		goto yy83
	}
	goto yy17
yy75:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy76
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy76
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy76:
	{ tok = token.ACTION; lit = "action"; return }
yy77:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy84
	}
	goto yy17
yy78:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy85
	}
	goto yy17
yy79:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy80
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy80
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy80:
	{ tok = token.ENTITY; lit = "entity"; return }
yy81:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy87
	}
	goto yy17
yy82:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy88
	}
	goto yy17
yy83:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy89
	}
	goto yy17
yy84:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'T') {
		goto yy90
	}
	goto yy17
yy85:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy86
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy86
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy86:
	{ tok = token.CONTEXT; lit = "context"; return }
yy87:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy91
	}
	goto yy17
yy88:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy92
	}
	goto yy17
yy89:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy93
	}
	goto yy17
yy90:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy95
	}
	goto yy17
yy91:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy97
	}
	goto yy17
yy92:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'l') {
		goto yy99
	}
	goto yy17
yy93:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy94
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy94
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy94:
	{ tok = token.RESOURCE; lit = "resource"; return }
yy95:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy96
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy96
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy96:
	{ tok = token.APPLIES_TO; lit = "appliesTo"; return }
yy97:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy98
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy98
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy98:
	{ tok = token.NAMESPACE; lit = "namespace"; return }
yy99:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy100
		}
		if (yych <= '9') {
			goto yy16
		}
		if (yych >= 'A') {
			goto yy16
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy16
			}
		} else {
			if (yych <= '`') {
				goto yy100
			}
			if (yych <= 'z') {
				goto yy16
			}
		}
	}
yy100:
	{ tok = token.PRINCIPAL; lit = "principal"; return }
}

    }
}

func (l *Lexer) lexString(quote byte) (pos token.Position, tok token.Type, lit string, err error) {
    pos = l.pos
    marker := 0
    var buf bytes.Buffer
    buf.WriteByte(quote)
    for {
        var u byte

        
{
	var yych byte
	yych = l.input[l.cursor]
	if (yych <= '\n') {
		if (yych <= 0x00) {
			goto yy102
		}
		if (yych <= '\t') {
			goto yy103
		}
		goto yy104
	} else {
		if (yych == '\\') {
			goto yy106
		}
		goto yy103
	}
yy102:
	l.cursor += 1
	{
            l.cursor -= 1 // make sure we don't overflow next lex call
            err = ErrUnterminatedString
            tok = token.EOF
            pos = l.pos
            return
        }
yy103:
	l.cursor += 1
	{
            u = yych
            buf.WriteByte(u)
            if u == quote {
                tok = token.STRING
                pos = l.pos
                lit = string(buf.Bytes())
                return
            }
            continue
        }
yy104:
	l.cursor += 1
yy105:
	{ err = ErrInvalidString; return }
yy106:
	l.cursor += 1
	marker = l.cursor
	yych = l.input[l.cursor]
	if (yych <= '\\') {
		if (yych <= '\'') {
			if (yych == '"') {
				goto yy107
			}
			if (yych <= '&') {
				goto yy105
			}
			goto yy108
		} else {
			if (yych == '0') {
				goto yy109
			}
			if (yych <= '[') {
				goto yy105
			}
			goto yy110
		}
	} else {
		if (yych <= 'r') {
			if (yych == 'n') {
				goto yy111
			}
			if (yych <= 'q') {
				goto yy105
			}
			goto yy112
		} else {
			if (yych <= 's') {
				goto yy105
			}
			if (yych <= 't') {
				goto yy113
			}
			if (yych <= 'u') {
				goto yy114
			}
			goto yy105
		}
	}
yy107:
	l.cursor += 1
	{ buf.WriteByte('"'); continue }
yy108:
	l.cursor += 1
	{ buf.WriteByte('\''); continue }
yy109:
	l.cursor += 1
	{ buf.WriteByte(0); continue }
yy110:
	l.cursor += 1
	{ buf.WriteByte('\\'); continue }
yy111:
	l.cursor += 1
	{ buf.WriteByte('\n'); continue }
yy112:
	l.cursor += 1
	{ buf.WriteByte('\r'); continue }
yy113:
	l.cursor += 1
	{ buf.WriteByte('\t'); continue }
yy114:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '{') {
		goto yy116
	}
yy115:
	l.cursor = marker
	goto yy105
yy116:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '}') {
		goto yy115
	}
	goto yy118
yy117:
	l.cursor += 1
	yych = l.input[l.cursor]
yy118:
	if (yych <= 'F') {
		if (yych <= '/') {
			goto yy115
		}
		if (yych <= '9') {
			goto yy117
		}
		if (yych <= '@') {
			goto yy115
		}
		goto yy117
	} else {
		if (yych <= 'f') {
			if (yych <= '`') {
				goto yy115
			}
			goto yy117
		} else {
			if (yych != '}') {
				goto yy115
			}
		}
	}
	l.cursor += 1
	{
            // Handle the hex digits between the braces
            hexStr := string(l.input[marker+2:l.cursor-1])  // Strip off \u{ and }
            if len(hexStr) % 2 != 0 {
                hexStr = "0" + hexStr
            }
            var val []byte
            val, err = hex.DecodeString(hexStr)
            if err != nil {
                pos = l.pos
                lit = string(buf.Bytes())
                err = fmt.Errorf("%w: %s", ErrInvalidString, err)
                return
            }
            buf.Write(val)
            continue
        }
}

    }
}
