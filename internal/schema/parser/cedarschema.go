// Code generated by re2c 2.2 on Sat Mar 22 19:30:00 2025, DO NOT EDIT.
package parser

import (
    "bytes"
    "fmt"
    "encoding/hex"

    "github.com/cedar-policy/cedar-go/internal/schema/token"
)

func (l *Lexer) lex() (pos token.Position, tok token.Type, lit string, err error) {
    for {
        lit = ""
        l.pos.Offset = l.cursor
        l.pos.Column = l.cursor - l.lineStart + 1
        l.token = l.cursor
        pos = l.pos

        
{
	var yych byte
	yych = l.input[l.cursor]
	switch (yych) {
	case 0x00:
		goto yy2
	case '\t':
		fallthrough
	case ' ':
		goto yy6
	case '\n':
		goto yy9
	case '\r':
		goto yy11
	case '"':
		goto yy12
	case ',':
		goto yy14
	case '/':
		goto yy16
	case ':':
		goto yy17
	case ';':
		goto yy19
	case '<':
		goto yy21
	case '=':
		goto yy23
	case '>':
		goto yy25
	case '?':
		goto yy27
	case 'A':
		fallthrough
	case 'B':
		fallthrough
	case 'C':
		fallthrough
	case 'D':
		fallthrough
	case 'E':
		fallthrough
	case 'F':
		fallthrough
	case 'G':
		fallthrough
	case 'H':
		fallthrough
	case 'I':
		fallthrough
	case 'J':
		fallthrough
	case 'K':
		fallthrough
	case 'L':
		fallthrough
	case 'M':
		fallthrough
	case 'N':
		fallthrough
	case 'O':
		fallthrough
	case 'P':
		fallthrough
	case 'Q':
		fallthrough
	case 'R':
		fallthrough
	case 'S':
		fallthrough
	case 'T':
		fallthrough
	case 'U':
		fallthrough
	case 'V':
		fallthrough
	case 'W':
		fallthrough
	case 'X':
		fallthrough
	case 'Y':
		fallthrough
	case 'Z':
		fallthrough
	case '_':
		fallthrough
	case 'b':
		fallthrough
	case 'd':
		fallthrough
	case 'f':
		fallthrough
	case 'g':
		fallthrough
	case 'h':
		fallthrough
	case 'j':
		fallthrough
	case 'k':
		fallthrough
	case 'l':
		fallthrough
	case 'm':
		fallthrough
	case 'o':
		fallthrough
	case 'q':
		fallthrough
	case 's':
		fallthrough
	case 'u':
		fallthrough
	case 'v':
		fallthrough
	case 'w':
		fallthrough
	case 'x':
		fallthrough
	case 'y':
		fallthrough
	case 'z':
		goto yy29
	case '[':
		goto yy32
	case ']':
		goto yy34
	case 'a':
		goto yy36
	case 'c':
		goto yy37
	case 'e':
		goto yy38
	case 'i':
		goto yy39
	case 'n':
		goto yy40
	case 'p':
		goto yy41
	case 'r':
		goto yy42
	case 't':
		goto yy43
	case '{':
		goto yy44
	case '}':
		goto yy46
	default:
		goto yy4
	}
yy2:
	l.cursor += 1
	{ l.cursor -= 1; tok = token.EOF; return }
yy4:
	l.cursor += 1
yy5:
	{ err = ErrUnrecognizedToken; return }
yy6:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '\t') {
		goto yy6
	}
	if (yych == ' ') {
		goto yy6
	}
	{
            continue
        }
yy9:
	l.cursor += 1
	{
            l.pos.Line += 1
            l.pos.Column = 1
            l.lineStart = l.cursor
            continue
        }
yy11:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '\n') {
		goto yy9
	}
	goto yy5
yy12:
	l.cursor += 1
	{ return l.lexString('"') }
yy14:
	l.cursor += 1
	{ tok = token.COMMA; lit = ","; return }
yy16:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '/') {
		goto yy48
	}
	goto yy5
yy17:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == ':') {
		goto yy51
	}
	{ tok = token.COLON; lit = ":"; return }
yy19:
	l.cursor += 1
	{ tok = token.SEMICOLON; lit = ";"; return }
yy21:
	l.cursor += 1
	{ tok = token.LEFTANGLE; lit = "<"; return }
yy23:
	l.cursor += 1
	{ tok = token.EQUALS; lit = "="; return }
yy25:
	l.cursor += 1
	{ tok = token.RIGHTANGLE; lit = ">"; return }
yy27:
	l.cursor += 1
	{ tok = token.QUESTION; lit = "?"; return }
yy29:
	l.cursor += 1
	yych = l.input[l.cursor]
yy30:
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy31
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy31
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy31:
	{ tok = token.IDENT; lit = l.literal(); return }
yy32:
	l.cursor += 1
	{ tok = token.LEFTBRACKET; lit = "["; return }
yy34:
	l.cursor += 1
	{ tok = token.RIGHTBRACKET; lit = "]"; return }
yy36:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy53
	}
	if (yych == 'p') {
		goto yy54
	}
	goto yy30
yy37:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy55
	}
	goto yy30
yy38:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy56
	}
	goto yy30
yy39:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy57
	}
	goto yy30
yy40:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy59
	}
	goto yy30
yy41:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'r') {
		goto yy60
	}
	goto yy30
yy42:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy61
	}
	goto yy30
yy43:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy62
	}
	if (yych == 'y') {
		goto yy63
	}
	goto yy30
yy44:
	l.cursor += 1
	{ tok = token.LEFTBRACE; lit = "{"; return }
yy46:
	l.cursor += 1
	{ tok = token.RIGHTBRACE; lit = "}"; return }
yy48:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= '\n') {
		if (yych <= 0x00) {
			goto yy50
		}
		if (yych <= '\t') {
			goto yy48
		}
	} else {
		if (yych != '\r') {
			goto yy48
		}
	}
yy50:
	{ tok = token.COMMENT; lit = l.literal(); return }
yy51:
	l.cursor += 1
	{ tok = token.DOUBLECOLON; lit = "::"; return }
yy53:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy64
	}
	goto yy30
yy54:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy65
	}
	goto yy30
yy55:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy66
	}
	goto yy30
yy56:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy67
	}
	goto yy30
yy57:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy58
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy58
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy58:
	{ tok = token.IN; lit = "in"; return }
yy59:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'm') {
		goto yy68
	}
	goto yy30
yy60:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy69
	}
	goto yy30
yy61:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy70
	}
	goto yy30
yy62:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'g') {
		goto yy71
	}
	goto yy30
yy63:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy72
	}
	goto yy30
yy64:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy73
	}
	goto yy30
yy65:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'l') {
		goto yy74
	}
	goto yy30
yy66:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy75
	}
	goto yy30
yy67:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy76
	}
	goto yy30
yy68:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy77
	}
	goto yy30
yy69:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy78
	}
	goto yy30
yy70:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy79
	}
	goto yy30
yy71:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy80
	}
	goto yy30
yy72:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy82
	}
	goto yy30
yy73:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy84
	}
	goto yy30
yy74:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy85
	}
	goto yy30
yy75:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy86
	}
	goto yy30
yy76:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy87
	}
	goto yy30
yy77:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy88
	}
	goto yy30
yy78:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy89
	}
	goto yy30
yy79:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'u') {
		goto yy90
	}
	goto yy30
yy80:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy81
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy81
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy81:
	{ tok = token.TAGS; lit = "tags"; return }
yy82:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy83
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy83
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy83:
	{ tok = token.TYPE; lit = "type"; return }
yy84:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'n') {
		goto yy91
	}
	goto yy30
yy85:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy93
	}
	goto yy30
yy86:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'x') {
		goto yy94
	}
	goto yy30
yy87:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'y') {
		goto yy95
	}
	goto yy30
yy88:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy97
	}
	goto yy30
yy89:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'i') {
		goto yy98
	}
	goto yy30
yy90:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'r') {
		goto yy99
	}
	goto yy30
yy91:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy92
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy92
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy92:
	{ tok = token.ACTION; lit = "action"; return }
yy93:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 's') {
		goto yy100
	}
	goto yy30
yy94:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 't') {
		goto yy101
	}
	goto yy30
yy95:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy96
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy96
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy96:
	{ tok = token.ENTITY; lit = "entity"; return }
yy97:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy103
	}
	goto yy30
yy98:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'p') {
		goto yy104
	}
	goto yy30
yy99:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy105
	}
	goto yy30
yy100:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'T') {
		goto yy106
	}
	goto yy30
yy101:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy102
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy102
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy102:
	{ tok = token.CONTEXT; lit = "context"; return }
yy103:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'c') {
		goto yy107
	}
	goto yy30
yy104:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'a') {
		goto yy108
	}
	goto yy30
yy105:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy109
	}
	goto yy30
yy106:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'o') {
		goto yy111
	}
	goto yy30
yy107:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'e') {
		goto yy113
	}
	goto yy30
yy108:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == 'l') {
		goto yy115
	}
	goto yy30
yy109:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy110
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy110
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy110:
	{ tok = token.RESOURCE; lit = "resource"; return }
yy111:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy112
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy112
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy112:
	{ tok = token.APPLIES_TO; lit = "appliesTo"; return }
yy113:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy114
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy114
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy114:
	{ tok = token.NAMESPACE; lit = "namespace"; return }
yy115:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych <= 'Z') {
		if (yych <= '/') {
			goto yy116
		}
		if (yych <= '9') {
			goto yy29
		}
		if (yych >= 'A') {
			goto yy29
		}
	} else {
		if (yych <= '_') {
			if (yych >= '_') {
				goto yy29
			}
		} else {
			if (yych <= '`') {
				goto yy116
			}
			if (yych <= 'z') {
				goto yy29
			}
		}
	}
yy116:
	{ tok = token.PRINCIPAL; lit = "principal"; return }
}

    }
}

func (l *Lexer) lexString(quote byte) (pos token.Position, tok token.Type, lit string, err error) {
    pos = l.pos
    marker := 0
    var buf bytes.Buffer
    buf.WriteByte(quote)
    for {
        var u byte

        
{
	var yych byte
	yych = l.input[l.cursor]
	if (yych <= '\n') {
		if (yych <= 0x00) {
			goto yy119
		}
		if (yych <= '\t') {
			goto yy121
		}
		goto yy123
	} else {
		if (yych == '\\') {
			goto yy125
		}
		goto yy121
	}
yy119:
	l.cursor += 1
	{
            l.cursor -= 1 // make sure we don't overflow next lex call
            err = ErrUnterminatedString
            tok = token.EOF
            pos = l.pos
            return
        }
yy121:
	l.cursor += 1
	{
            u = yych
            buf.WriteByte(u)
            if u == quote {
                tok = token.STRING
                pos = l.pos
                lit = string(buf.Bytes())
                return
            }
            continue
        }
yy123:
	l.cursor += 1
yy124:
	{ err = ErrInvalidString; return }
yy125:
	l.cursor += 1
	marker = l.cursor
	yych = l.input[l.cursor]
	if (yych <= '\\') {
		if (yych <= '\'') {
			if (yych == '"') {
				goto yy126
			}
			if (yych <= '&') {
				goto yy124
			}
			goto yy128
		} else {
			if (yych == '0') {
				goto yy130
			}
			if (yych <= '[') {
				goto yy124
			}
			goto yy132
		}
	} else {
		if (yych <= 'r') {
			if (yych == 'n') {
				goto yy134
			}
			if (yych <= 'q') {
				goto yy124
			}
			goto yy136
		} else {
			if (yych <= 's') {
				goto yy124
			}
			if (yych <= 't') {
				goto yy138
			}
			if (yych <= 'u') {
				goto yy140
			}
			goto yy124
		}
	}
yy126:
	l.cursor += 1
	{ buf.WriteByte('"'); continue }
yy128:
	l.cursor += 1
	{ buf.WriteByte('\''); continue }
yy130:
	l.cursor += 1
	{ buf.WriteByte(0); continue }
yy132:
	l.cursor += 1
	{ buf.WriteByte('\\'); continue }
yy134:
	l.cursor += 1
	{ buf.WriteByte('\n'); continue }
yy136:
	l.cursor += 1
	{ buf.WriteByte('\r'); continue }
yy138:
	l.cursor += 1
	{ buf.WriteByte('\t'); continue }
yy140:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '{') {
		goto yy142
	}
yy141:
	l.cursor = marker
	goto yy124
yy142:
	l.cursor += 1
	yych = l.input[l.cursor]
	if (yych == '}') {
		goto yy141
	}
	goto yy144
yy143:
	l.cursor += 1
	yych = l.input[l.cursor]
yy144:
	if (yych <= 'F') {
		if (yych <= '/') {
			goto yy141
		}
		if (yych <= '9') {
			goto yy143
		}
		if (yych <= '@') {
			goto yy141
		}
		goto yy143
	} else {
		if (yych <= 'f') {
			if (yych <= '`') {
				goto yy141
			}
			goto yy143
		} else {
			if (yych != '}') {
				goto yy141
			}
		}
	}
	l.cursor += 1
	{
            // Handle the hex digits between the braces
            hexStr := string(l.input[marker+2:l.cursor-1])  // Strip off \u{ and }
            if len(hexStr) % 2 != 0 {
                hexStr = "0" + hexStr
            }
            var val []byte
            val, err = hex.DecodeString(hexStr)
            if err != nil {
                pos = l.pos
                lit = string(buf.Bytes())
                err = fmt.Errorf("%w: %s", ErrInvalidString, err)
                return
            }
            buf.Write(val)
            continue
        }
}

    }
}
