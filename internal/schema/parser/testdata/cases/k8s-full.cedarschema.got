// From https://raw.githubusercontent.com/awslabs/cedar-access-control-for-k8s/refs/heads/main/cedarschema/k8s-full.cedarschema
// This file was modified in the following ways to be formatted:
// - This comment was added at the start
// - The formatting was changed to match the formatter's rules
namespace k8s::admission {
  action "all" appliesTo {
    principal: [k8s::Group, k8s::Node, k8s::ServiceAccount, k8s::User],
    resource: [admissionregistration::v1::MutatingWebhookConfiguration, admissionregistration::v1::ValidatingAdmissionPolicy, admissionregistration::v1::ValidatingAdmissionPolicyBinding, admissionregistration::v1::ValidatingWebhookConfiguration, apps::v1::ControllerRevision, apps::v1::DaemonSet, apps::v1::Deployment, apps::v1::ReplicaSet, apps::v1::StatefulSet, authentication::v1::SelfSubjectReview, authentication::v1::TokenRequest, authentication::v1::TokenReview, authorization::v1::LocalSubjectAccessReview, authorization::v1::SelfSubjectAccessReview, authorization::v1::SelfSubjectRulesReview, authorization::v1::SubjectAccessReview, autoscaling::v1::HorizontalPodAutoscaler, autoscaling::v1::Scale, autoscaling::v2::HorizontalPodAutoscaler, aws::k8s::cedar::v1alpha1::Policy, batch::v1::CronJob, batch::v1::Job, certificates::v1::CertificateSigningRequest, coordination::v1::Lease, core::v1::Binding, core::v1::ComponentStatus, core::v1::ConfigMap, core::v1::Endpoints, core::v1::Event, core::v1::LimitRange, core::v1::Namespace, core::v1::Node, core::v1::PersistentVolume, core::v1::PersistentVolumeClaim, core::v1::Pod, core::v1::PodTemplate, core::v1::ReplicationController, core::v1::ResourceQuota, core::v1::Secret, core::v1::Service, core::v1::ServiceAccount, discovery::v1::EndpointSlice, events::v1::Event, flowcontrol::v1::FlowSchema, flowcontrol::v1::PriorityLevelConfiguration, flowcontrol::v1beta3::FlowSchema, flowcontrol::v1beta3::PriorityLevelConfiguration, networking::v1::Ingress, networking::v1::IngressClass, networking::v1::NetworkPolicy, node::v1::RuntimeClass, policy::v1::Eviction, policy::v1::PodDisruptionBudget, rbac::v1::ClusterRole, rbac::v1::ClusterRoleBinding, rbac::v1::Role, rbac::v1::RoleBinding, scheduling::v1::PriorityClass, storage::v1::CSIDriver, storage::v1::CSINode, storage::v1::CSIStorageCapacity, storage::v1::StorageClass, storage::v1::VolumeAttachment],
    context: {
    },
  };
  action "connect" in Action::"all" appliesTo {
    principal: [k8s::Group, k8s::Node, k8s::ServiceAccount, k8s::User],
    resource: [core::v1::NodeProxyOptions, core::v1::PodAttachOptions, core::v1::PodExecOptions, core::v1::PodPortForwardOptions, core::v1::PodProxyOptions, core::v1::ServiceProxyOptions],
    context: {
    },
  };
  action "create" in Action::"all" appliesTo {
    principal: [k8s::Group, k8s::Node, k8s::ServiceAccount, k8s::User],
    resource: [admissionregistration::v1::MutatingWebhookConfiguration, admissionregistration::v1::ValidatingAdmissionPolicy, admissionregistration::v1::ValidatingAdmissionPolicyBinding, admissionregistration::v1::ValidatingWebhookConfiguration, apps::v1::ControllerRevision, apps::v1::DaemonSet, apps::v1::Deployment, apps::v1::ReplicaSet, apps::v1::StatefulSet, authentication::v1::SelfSubjectReview, authentication::v1::TokenRequest, authentication::v1::TokenReview, authorization::v1::LocalSubjectAccessReview, authorization::v1::SelfSubjectAccessReview, authorization::v1::SelfSubjectRulesReview, authorization::v1::SubjectAccessReview, autoscaling::v1::HorizontalPodAutoscaler, autoscaling::v2::HorizontalPodAutoscaler, aws::k8s::cedar::v1alpha1::Policy, batch::v1::CronJob, batch::v1::Job, certificates::v1::CertificateSigningRequest, coordination::v1::Lease, core::v1::Binding, core::v1::ConfigMap, core::v1::Endpoints, core::v1::Event, core::v1::LimitRange, core::v1::Namespace, core::v1::Node, core::v1::PersistentVolume, core::v1::PersistentVolumeClaim, core::v1::Pod, core::v1::PodTemplate, core::v1::ReplicationController, core::v1::ResourceQuota, core::v1::Secret, core::v1::Service, core::v1::ServiceAccount, discovery::v1::EndpointSlice, events::v1::Event, flowcontrol::v1::FlowSchema, flowcontrol::v1::PriorityLevelConfiguration, flowcontrol::v1beta3::FlowSchema, flowcontrol::v1beta3::PriorityLevelConfiguration, networking::v1::Ingress, networking::v1::IngressClass, networking::v1::NetworkPolicy, node::v1::RuntimeClass, policy::v1::Eviction, policy::v1::PodDisruptionBudget, rbac::v1::ClusterRole, rbac::v1::ClusterRoleBinding, rbac::v1::Role, rbac::v1::RoleBinding, scheduling::v1::PriorityClass, storage::v1::CSIDriver, storage::v1::CSINode, storage::v1::CSIStorageCapacity, storage::v1::StorageClass, storage::v1::VolumeAttachment],
    context: {
    },
  };
  action "delete" in Action::"all" appliesTo {
    principal: [k8s::Group, k8s::Node, k8s::ServiceAccount, k8s::User],
    resource: [admissionregistration::v1::MutatingWebhookConfiguration, admissionregistration::v1::ValidatingAdmissionPolicy, admissionregistration::v1::ValidatingAdmissionPolicyBinding, admissionregistration::v1::ValidatingWebhookConfiguration, apps::v1::ControllerRevision, apps::v1::DaemonSet, apps::v1::Deployment, apps::v1::ReplicaSet, apps::v1::StatefulSet, autoscaling::v1::HorizontalPodAutoscaler, autoscaling::v2::HorizontalPodAutoscaler, aws::k8s::cedar::v1alpha1::Policy, batch::v1::CronJob, batch::v1::Job, certificates::v1::CertificateSigningRequest, coordination::v1::Lease, core::v1::ConfigMap, core::v1::Endpoints, core::v1::Event, core::v1::LimitRange, core::v1::Namespace, core::v1::Node, core::v1::PersistentVolume, core::v1::PersistentVolumeClaim, core::v1::Pod, core::v1::PodTemplate, core::v1::ReplicationController, core::v1::ResourceQuota, core::v1::Secret, core::v1::Service, core::v1::ServiceAccount, discovery::v1::EndpointSlice, events::v1::Event, flowcontrol::v1::FlowSchema, flowcontrol::v1::PriorityLevelConfiguration, flowcontrol::v1beta3::FlowSchema, flowcontrol::v1beta3::PriorityLevelConfiguration, networking::v1::Ingress, networking::v1::IngressClass, networking::v1::NetworkPolicy, node::v1::RuntimeClass, policy::v1::PodDisruptionBudget, rbac::v1::ClusterRole, rbac::v1::ClusterRoleBinding, rbac::v1::Role, rbac::v1::RoleBinding, scheduling::v1::PriorityClass, storage::v1::CSIDriver, storage::v1::CSINode, storage::v1::CSIStorageCapacity, storage::v1::StorageClass, storage::v1::VolumeAttachment],
    context: {
    },
  };
  action "update" in Action::"all" appliesTo {
    principal: [k8s::Group, k8s::Node, k8s::ServiceAccount, k8s::User],
    resource: [admissionregistration::v1::MutatingWebhookConfiguration, admissionregistration::v1::ValidatingAdmissionPolicy, admissionregistration::v1::ValidatingAdmissionPolicyBinding, admissionregistration::v1::ValidatingWebhookConfiguration, apps::v1::ControllerRevision, apps::v1::DaemonSet, apps::v1::Deployment, apps::v1::ReplicaSet, apps::v1::StatefulSet, autoscaling::v1::HorizontalPodAutoscaler, autoscaling::v1::Scale, autoscaling::v2::HorizontalPodAutoscaler, aws::k8s::cedar::v1alpha1::Policy, batch::v1::CronJob, batch::v1::Job, certificates::v1::CertificateSigningRequest, coordination::v1::Lease, core::v1::ConfigMap, core::v1::Endpoints, core::v1::Event, core::v1::LimitRange, core::v1::Namespace, core::v1::Node, core::v1::PersistentVolume, core::v1::PersistentVolumeClaim, core::v1::Pod, core::v1::PodTemplate, core::v1::ReplicationController, core::v1::ResourceQuota, core::v1::Secret, core::v1::Service, core::v1::ServiceAccount, discovery::v1::EndpointSlice, events::v1::Event, flowcontrol::v1::FlowSchema, flowcontrol::v1::PriorityLevelConfiguration, flowcontrol::v1beta3::FlowSchema, flowcontrol::v1beta3::PriorityLevelConfiguration, networking::v1::Ingress, networking::v1::IngressClass, networking::v1::NetworkPolicy, node::v1::RuntimeClass, policy::v1::PodDisruptionBudget, rbac::v1::ClusterRole, rbac::v1::ClusterRoleBinding, rbac::v1::Role, rbac::v1::RoleBinding, scheduling::v1::PriorityClass, storage::v1::CSIDriver, storage::v1::CSINode, storage::v1::CSIStorageCapacity, storage::v1::StorageClass, storage::v1::VolumeAttachment],
    context: {
    },
  };
}
namespace k8s {
  type ExtraAttribute = {
    "key": __cedar::String,
    "values": Set<__cedar::String>,
  };
  type FieldRequirement = {
    "field": __cedar::String,
    "operator": __cedar::String,
    "value": __cedar::String,
  };
  type LabelRequirement = {
    "key": __cedar::String,
    "operator": __cedar::String,
    "values": Set<__cedar::String>,
  };
  entity Extra = {
    "key": __cedar::String,
    "value"?: __cedar::String,
  };
  entity Group = {
    "name": __cedar::String,
  };
  entity Node in Group = {
    "extra"?: Set<ExtraAttribute>,
    "name": __cedar::String,
  };
  entity NonResourceURL = {
    "path": __cedar::String,
  };
  entity PrincipalUID;
  entity Resource = {
    "apiGroup": __cedar::String,
    "fieldSelector"?: Set<FieldRequirement>,
    "labelSelector"?: Set<LabelRequirement>,
    "name"?: __cedar::String,
    "namespace"?: __cedar::String,
    "resource": __cedar::String,
    "subresource"?: __cedar::String,
  };
  entity ServiceAccount in Group = {
    "extra"?: Set<ExtraAttribute>,
    "name": __cedar::String,
    "namespace": __cedar::String,
  };
  entity User in Group = {
    "extra"?: Set<ExtraAttribute>,
    "name": __cedar::String,
  };
  action "approve" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "attest" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "bind" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "create" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "delete" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: [NonResourceURL, Resource],
    context: {
    },
  };
  action "deletecollection" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "escalate" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "get" in Action::"readOnly" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: [NonResourceURL, Resource],
    context: {
    },
  };
  action "head" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: NonResourceURL,
    context: {
    },
  };
  action "impersonate" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: [Extra, Group, Node, PrincipalUID, ServiceAccount, User],
    context: {
    },
  };
  action "list" in Action::"readOnly" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "options" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: NonResourceURL,
    context: {
    },
  };
  action "patch" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: [NonResourceURL, Resource],
    context: {
    },
  };
  action "post" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: NonResourceURL,
    context: {
    },
  };
  action "put" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: NonResourceURL,
    context: {
    },
  };
  action "readOnly" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "sign" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "update" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "use" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
  action "watch" in Action::"readOnly" appliesTo {
    principal: [Group, Node, ServiceAccount, User],
    resource: Resource,
    context: {
    },
  };
}
namespace admissionregistration::v1 {
  type AuditAnnotation = {
    "key": __cedar::String,
    "valueExpression": __cedar::String,
  };
  type ExpressionWarning = {
    "fieldRef": __cedar::String,
    "warning": __cedar::String,
  };
  type MatchCondition = {
    "expression": __cedar::String,
    "name": __cedar::String,
  };
  type MatchResources = {
    "excludeResourceRules"?: Set<NamedRuleWithOperations>,
    "matchPolicy"?: __cedar::String,
    "namespaceSelector"?: meta::v1::LabelSelector,
    "objectSelector"?: meta::v1::LabelSelector,
    "resourceRules"?: Set<NamedRuleWithOperations>,
  };
  type MutatingWebhook = {
    "admissionReviewVersions": Set<__cedar::String>,
    "clientConfig": WebhookClientConfig,
    "failurePolicy"?: __cedar::String,
    "matchConditions"?: Set<MatchCondition>,
    "matchPolicy"?: __cedar::String,
    "name": __cedar::String,
    "namespaceSelector"?: meta::v1::LabelSelector,
    "objectSelector"?: meta::v1::LabelSelector,
    "reinvocationPolicy"?: __cedar::String,
    "rules"?: Set<RuleWithOperations>,
    "sideEffects": __cedar::String,
    "timeoutSeconds"?: __cedar::Long,
  };
  type NamedRuleWithOperations = {
    "apiGroups"?: Set<__cedar::String>,
    "apiVersions"?: Set<__cedar::String>,
    "operations"?: Set<__cedar::String>,
    "resourceNames"?: Set<__cedar::String>,
    "resources"?: Set<__cedar::String>,
    "scope"?: __cedar::String,
  };
  type ParamKind = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
  };
  type ParamRef = {
    "name"?: __cedar::String,
    "namespace"?: __cedar::String,
    "parameterNotFoundAction"?: __cedar::String,
    "selector"?: meta::v1::LabelSelector,
  };
  type RuleWithOperations = {
    "apiGroups"?: Set<__cedar::String>,
    "apiVersions"?: Set<__cedar::String>,
    "operations"?: Set<__cedar::String>,
    "resources"?: Set<__cedar::String>,
    "scope"?: __cedar::String,
  };
  type ServiceReference = {
    "name": __cedar::String,
    "namespace": __cedar::String,
    "path"?: __cedar::String,
    "port"?: __cedar::Long,
  };
  type TypeChecking = {
    "expressionWarnings"?: Set<ExpressionWarning>,
  };
  type ValidatingAdmissionPolicyBindingSpec = {
    "matchResources"?: MatchResources,
    "paramRef"?: ParamRef,
    "policyName"?: __cedar::String,
    "validationActions"?: Set<__cedar::String>,
  };
  type ValidatingAdmissionPolicySpec = {
    "auditAnnotations"?: Set<AuditAnnotation>,
    "failurePolicy"?: __cedar::String,
    "matchConditions"?: Set<MatchCondition>,
    "matchConstraints"?: MatchResources,
    "paramKind"?: ParamKind,
    "validations"?: Set<Validation>,
    "variables"?: Set<Variable>,
  };
  type ValidatingAdmissionPolicyStatus = {
    "conditions"?: Set<meta::v1::Condition>,
    "observedGeneration"?: __cedar::Long,
    "typeChecking"?: TypeChecking,
  };
  type ValidatingWebhook = {
    "admissionReviewVersions": Set<__cedar::String>,
    "clientConfig": WebhookClientConfig,
    "failurePolicy"?: __cedar::String,
    "matchConditions"?: Set<MatchCondition>,
    "matchPolicy"?: __cedar::String,
    "name": __cedar::String,
    "namespaceSelector"?: meta::v1::LabelSelector,
    "objectSelector"?: meta::v1::LabelSelector,
    "rules"?: Set<RuleWithOperations>,
    "sideEffects": __cedar::String,
    "timeoutSeconds"?: __cedar::Long,
  };
  type Validation = {
    "expression": __cedar::String,
    "message"?: __cedar::String,
    "messageExpression"?: __cedar::String,
    "reason"?: __cedar::String,
  };
  type Variable = {
    "expression": __cedar::String,
    "name": __cedar::String,
  };
  type WebhookClientConfig = {
    "caBundle"?: __cedar::String,
    "service"?: ServiceReference,
    "url"?: __cedar::String,
  };
  entity MutatingWebhookConfiguration = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: MutatingWebhookConfiguration,
    "webhooks"?: Set<MutatingWebhook>,
  };
  entity ValidatingAdmissionPolicy = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ValidatingAdmissionPolicy,
    "spec"?: ValidatingAdmissionPolicySpec,
    "status"?: ValidatingAdmissionPolicyStatus,
  };
  entity ValidatingAdmissionPolicyBinding = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ValidatingAdmissionPolicyBinding,
    "spec"?: ValidatingAdmissionPolicyBindingSpec,
  };
  entity ValidatingWebhookConfiguration = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ValidatingWebhookConfiguration,
    "webhooks"?: Set<ValidatingWebhook>,
  };
}
namespace apps::v1 {
  type DaemonSetCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type DaemonSetSpec = {
    "minReadySeconds"?: __cedar::Long,
    "revisionHistoryLimit"?: __cedar::Long,
    "selector": meta::v1::LabelSelector,
    "template": core::v1::PodTemplateSpec,
    "updateStrategy"?: DaemonSetUpdateStrategy,
  };
  type DaemonSetStatus = {
    "collisionCount"?: __cedar::Long,
    "conditions"?: Set<DaemonSetCondition>,
    "currentNumberScheduled": __cedar::Long,
    "desiredNumberScheduled": __cedar::Long,
    "numberAvailable"?: __cedar::Long,
    "numberMisscheduled": __cedar::Long,
    "numberReady": __cedar::Long,
    "numberUnavailable"?: __cedar::Long,
    "observedGeneration"?: __cedar::Long,
    "updatedNumberScheduled"?: __cedar::Long,
  };
  type DaemonSetUpdateStrategy = {
    "rollingUpdate"?: RollingUpdateDaemonSet,
    "type"?: __cedar::String,
  };
  type DeploymentCondition = {
    "lastTransitionTime"?: __cedar::String,
    "lastUpdateTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type DeploymentSpec = {
    "minReadySeconds"?: __cedar::Long,
    "paused"?: __cedar::Bool,
    "progressDeadlineSeconds"?: __cedar::Long,
    "replicas"?: __cedar::Long,
    "revisionHistoryLimit"?: __cedar::Long,
    "selector": meta::v1::LabelSelector,
    "strategy"?: DeploymentStrategy,
    "template": core::v1::PodTemplateSpec,
  };
  type DeploymentStatus = {
    "availableReplicas"?: __cedar::Long,
    "collisionCount"?: __cedar::Long,
    "conditions"?: Set<DeploymentCondition>,
    "observedGeneration"?: __cedar::Long,
    "readyReplicas"?: __cedar::Long,
    "replicas"?: __cedar::Long,
    "unavailableReplicas"?: __cedar::Long,
    "updatedReplicas"?: __cedar::Long,
  };
  type DeploymentStrategy = {
    "rollingUpdate"?: RollingUpdateDeployment,
    "type"?: __cedar::String,
  };
  type ReplicaSetCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type ReplicaSetSpec = {
    "minReadySeconds"?: __cedar::Long,
    "replicas"?: __cedar::Long,
    "selector": meta::v1::LabelSelector,
    "template"?: core::v1::PodTemplateSpec,
  };
  type ReplicaSetStatus = {
    "availableReplicas"?: __cedar::Long,
    "conditions"?: Set<ReplicaSetCondition>,
    "fullyLabeledReplicas"?: __cedar::Long,
    "observedGeneration"?: __cedar::Long,
    "readyReplicas"?: __cedar::Long,
    "replicas": __cedar::Long,
  };
  type RollingUpdateDaemonSet = {
    "maxSurge"?: __cedar::String,
    "maxUnavailable"?: __cedar::String,
  };
  type RollingUpdateDeployment = {
    "maxSurge"?: __cedar::String,
    "maxUnavailable"?: __cedar::String,
  };
  type RollingUpdateStatefulSetStrategy = {
    "maxUnavailable"?: __cedar::String,
    "partition"?: __cedar::Long,
  };
  type StatefulSetCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type StatefulSetOrdinals = {
    "start"?: __cedar::Long,
  };
  type StatefulSetPersistentVolumeClaimRetentionPolicy = {
    "whenDeleted"?: __cedar::String,
    "whenScaled"?: __cedar::String,
  };
  type StatefulSetSpec = {
    "minReadySeconds"?: __cedar::Long,
    "ordinals"?: StatefulSetOrdinals,
    "persistentVolumeClaimRetentionPolicy"?: StatefulSetPersistentVolumeClaimRetentionPolicy,
    "podManagementPolicy"?: __cedar::String,
    "replicas"?: __cedar::Long,
    "revisionHistoryLimit"?: __cedar::Long,
    "selector": meta::v1::LabelSelector,
    "serviceName": __cedar::String,
    "template": core::v1::PodTemplateSpec,
    "updateStrategy"?: StatefulSetUpdateStrategy,
    "volumeClaimTemplates"?: Set<core::v1::PersistentVolumeClaim>,
  };
  type StatefulSetStatus = {
    "availableReplicas"?: __cedar::Long,
    "collisionCount"?: __cedar::Long,
    "conditions"?: Set<StatefulSetCondition>,
    "currentReplicas"?: __cedar::Long,
    "currentRevision"?: __cedar::String,
    "observedGeneration"?: __cedar::Long,
    "readyReplicas"?: __cedar::Long,
    "replicas": __cedar::Long,
    "updateRevision"?: __cedar::String,
    "updatedReplicas"?: __cedar::Long,
  };
  type StatefulSetUpdateStrategy = {
    "rollingUpdate"?: RollingUpdateStatefulSetStrategy,
    "type"?: __cedar::String,
  };
  entity ControllerRevision = {
    "apiVersion"?: __cedar::String,
    "data"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ControllerRevision,
    "revision": __cedar::Long,
  };
  entity DaemonSet = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: DaemonSet,
    "spec"?: DaemonSetSpec,
    "status"?: DaemonSetStatus,
  };
  entity Deployment = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Deployment,
    "spec"?: DeploymentSpec,
    "status"?: DeploymentStatus,
  };
  entity ReplicaSet = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ReplicaSet,
    "spec"?: ReplicaSetSpec,
    "status"?: ReplicaSetStatus,
  };
  entity StatefulSet = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: StatefulSet,
    "spec"?: StatefulSetSpec,
    "status"?: StatefulSetStatus,
  };
}
namespace authentication::v1 {
  type BoundObjectReference = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "name"?: __cedar::String,
    "uid"?: __cedar::String,
  };
  type SelfSubjectReviewStatus = {
    "userInfo"?: UserInfo,
  };
  type TokenRequestSpec = {
    "audiences": Set<__cedar::String>,
    "boundObjectRef"?: BoundObjectReference,
    "expirationSeconds"?: __cedar::Long,
  };
  type TokenRequestStatus = {
    "expirationTimestamp": __cedar::String,
    "token": __cedar::String,
  };
  type TokenReviewSpec = {
    "audiences"?: Set<__cedar::String>,
    "token"?: __cedar::String,
  };
  type TokenReviewStatus = {
    "audiences"?: Set<__cedar::String>,
    "authenticated"?: __cedar::Bool,
    "error"?: __cedar::String,
    "user"?: UserInfo,
  };
  type UserInfo = {
    "extra"?: Set<meta::v1::KeyValueStringSlice>,
    "groups"?: Set<__cedar::String>,
    "uid"?: __cedar::String,
    "username"?: __cedar::String,
  };
  entity SelfSubjectReview = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "status"?: SelfSubjectReviewStatus,
  };
  entity TokenRequest = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "spec": TokenRequestSpec,
    "status"?: TokenRequestStatus,
  };
  entity TokenReview = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "spec": TokenReviewSpec,
    "status"?: TokenReviewStatus,
  };
}
namespace authorization::v1 {
  type FieldSelectorAttributes = {
    "rawSelector"?: __cedar::String,
    "requirements"?: Set<meta::v1::FieldSelectorRequirement>,
  };
  type LabelSelectorAttributes = {
    "rawSelector"?: __cedar::String,
    "requirements"?: Set<meta::v1::LabelSelectorRequirement>,
  };
  type NonResourceAttributes = {
    "path"?: __cedar::String,
    "verb"?: __cedar::String,
  };
  type NonResourceRule = {
    "nonResourceURLs"?: Set<__cedar::String>,
    "verbs": Set<__cedar::String>,
  };
  type ResourceAttributes = {
    "fieldSelector"?: FieldSelectorAttributes,
    "group"?: __cedar::String,
    "labelSelector"?: LabelSelectorAttributes,
    "name"?: __cedar::String,
    "namespace"?: __cedar::String,
    "resource"?: __cedar::String,
    "subresource"?: __cedar::String,
    "verb"?: __cedar::String,
    "version"?: __cedar::String,
  };
  type ResourceRule = {
    "apiGroups"?: Set<__cedar::String>,
    "resourceNames"?: Set<__cedar::String>,
    "resources"?: Set<__cedar::String>,
    "verbs": Set<__cedar::String>,
  };
  type SelfSubjectAccessReviewSpec = {
    "nonResourceAttributes"?: NonResourceAttributes,
    "resourceAttributes"?: ResourceAttributes,
  };
  type SelfSubjectRulesReviewSpec = {
    "namespace"?: __cedar::String,
  };
  type SubjectAccessReviewSpec = {
    "extra"?: Set<meta::v1::KeyValueStringSlice>,
    "groups"?: Set<__cedar::String>,
    "nonResourceAttributes"?: NonResourceAttributes,
    "resourceAttributes"?: ResourceAttributes,
    "uid"?: __cedar::String,
    "user"?: __cedar::String,
  };
  type SubjectAccessReviewStatus = {
    "allowed": __cedar::Bool,
    "denied"?: __cedar::Bool,
    "evaluationError"?: __cedar::String,
    "reason"?: __cedar::String,
  };
  type SubjectRulesReviewStatus = {
    "evaluationError"?: __cedar::String,
    "incomplete": __cedar::Bool,
    "nonResourceRules": Set<NonResourceRule>,
    "resourceRules": Set<ResourceRule>,
  };
  entity LocalSubjectAccessReview = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "spec": SubjectAccessReviewSpec,
    "status"?: SubjectAccessReviewStatus,
  };
  entity SelfSubjectAccessReview = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "spec": SelfSubjectAccessReviewSpec,
    "status"?: SubjectAccessReviewStatus,
  };
  entity SelfSubjectRulesReview = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "spec": SelfSubjectRulesReviewSpec,
    "status"?: SubjectRulesReviewStatus,
  };
  entity SubjectAccessReview = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "spec": SubjectAccessReviewSpec,
    "status"?: SubjectAccessReviewStatus,
  };
}
namespace autoscaling::v1 {
  type CrossVersionObjectReference = {
    "apiVersion"?: __cedar::String,
    "kind": __cedar::String,
    "name": __cedar::String,
  };
  type HorizontalPodAutoscalerSpec = {
    "maxReplicas": __cedar::Long,
    "minReplicas"?: __cedar::Long,
    "scaleTargetRef": CrossVersionObjectReference,
    "targetCPUUtilizationPercentage"?: __cedar::Long,
  };
  type HorizontalPodAutoscalerStatus = {
    "currentCPUUtilizationPercentage"?: __cedar::Long,
    "currentReplicas": __cedar::Long,
    "desiredReplicas": __cedar::Long,
    "lastScaleTime"?: __cedar::String,
    "observedGeneration"?: __cedar::Long,
  };
  type ScaleSpec = {
    "replicas"?: __cedar::Long,
  };
  type ScaleStatus = {
    "replicas": __cedar::Long,
    "selector"?: __cedar::String,
  };
  entity HorizontalPodAutoscaler = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: HorizontalPodAutoscaler,
    "spec"?: HorizontalPodAutoscalerSpec,
    "status"?: HorizontalPodAutoscalerStatus,
  };
  entity Scale = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Scale,
    "spec"?: ScaleSpec,
    "status"?: ScaleStatus,
  };
}
namespace batch::v1 {
  type CronJobSpec = {
    "concurrencyPolicy"?: __cedar::String,
    "failedJobsHistoryLimit"?: __cedar::Long,
    "jobTemplate": JobTemplateSpec,
    "schedule": __cedar::String,
    "startingDeadlineSeconds"?: __cedar::Long,
    "successfulJobsHistoryLimit"?: __cedar::Long,
    "suspend"?: __cedar::Bool,
    "timeZone"?: __cedar::String,
  };
  type CronJobStatus = {
    "active"?: Set<core::v1::ObjectReference>,
    "lastScheduleTime"?: __cedar::String,
    "lastSuccessfulTime"?: __cedar::String,
  };
  type JobCondition = {
    "lastProbeTime"?: __cedar::String,
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type JobSpec = {
    "activeDeadlineSeconds"?: __cedar::Long,
    "backoffLimit"?: __cedar::Long,
    "backoffLimitPerIndex"?: __cedar::Long,
    "completionMode"?: __cedar::String,
    "completions"?: __cedar::Long,
    "managedBy"?: __cedar::String,
    "manualSelector"?: __cedar::Bool,
    "maxFailedIndexes"?: __cedar::Long,
    "parallelism"?: __cedar::Long,
    "podFailurePolicy"?: PodFailurePolicy,
    "podReplacementPolicy"?: __cedar::String,
    "selector"?: meta::v1::LabelSelector,
    "successPolicy"?: SuccessPolicy,
    "suspend"?: __cedar::Bool,
    "template": core::v1::PodTemplateSpec,
    "ttlSecondsAfterFinished"?: __cedar::Long,
  };
  type JobStatus = {
    "active"?: __cedar::Long,
    "completedIndexes"?: __cedar::String,
    "completionTime"?: __cedar::String,
    "conditions"?: Set<JobCondition>,
    "failed"?: __cedar::Long,
    "failedIndexes"?: __cedar::String,
    "ready"?: __cedar::Long,
    "startTime"?: __cedar::String,
    "succeeded"?: __cedar::Long,
    "terminating"?: __cedar::Long,
    "uncountedTerminatedPods"?: UncountedTerminatedPods,
  };
  type JobTemplateSpec = {
    "metadata"?: meta::v1::ObjectMeta,
    "spec"?: JobSpec,
  };
  type PodFailurePolicy = {
    "rules": Set<PodFailurePolicyRule>,
  };
  type PodFailurePolicyOnExitCodesRequirement = {
    "containerName"?: __cedar::String,
    "operator": __cedar::String,
    "values": Set<__cedar::Long>,
  };
  type PodFailurePolicyOnPodConditionsPattern = {
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type PodFailurePolicyRule = {
    "action": __cedar::String,
    "onExitCodes"?: PodFailurePolicyOnExitCodesRequirement,
    "onPodConditions"?: Set<PodFailurePolicyOnPodConditionsPattern>,
  };
  type SuccessPolicy = {
    "rules": Set<SuccessPolicyRule>,
  };
  type SuccessPolicyRule = {
    "succeededCount"?: __cedar::Long,
    "succeededIndexes"?: __cedar::String,
  };
  type UncountedTerminatedPods = {
    "failed"?: Set<__cedar::String>,
    "succeeded"?: Set<__cedar::String>,
  };
  entity CronJob = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: CronJob,
    "spec"?: CronJobSpec,
    "status"?: CronJobStatus,
  };
  entity Job = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Job,
    "spec"?: JobSpec,
    "status"?: JobStatus,
  };
}
namespace certificates::v1 {
  type CertificateSigningRequestCondition = {
    "lastTransitionTime"?: __cedar::String,
    "lastUpdateTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type CertificateSigningRequestSpec = {
    "expirationSeconds"?: __cedar::Long,
    "extra"?: Set<meta::v1::KeyValueStringSlice>,
    "groups"?: Set<__cedar::String>,
    "request": __cedar::String,
    "signerName": __cedar::String,
    "uid"?: __cedar::String,
    "usages"?: Set<__cedar::String>,
    "username"?: __cedar::String,
  };
  type CertificateSigningRequestStatus = {
    "certificate"?: __cedar::String,
    "conditions"?: Set<CertificateSigningRequestCondition>,
  };
  entity CertificateSigningRequest = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: CertificateSigningRequest,
    "spec": CertificateSigningRequestSpec,
    "status"?: CertificateSigningRequestStatus,
  };
}
namespace coordination::v1 {
  type LeaseSpec = {
    "acquireTime"?: __cedar::String,
    "holderIdentity"?: __cedar::String,
    "leaseDurationSeconds"?: __cedar::Long,
    "leaseTransitions"?: __cedar::Long,
    "preferredHolder"?: __cedar::String,
    "renewTime"?: __cedar::String,
    "strategy"?: __cedar::String,
  };
  entity Lease = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Lease,
    "spec"?: LeaseSpec,
  };
}
namespace core::v1 {
  type AWSElasticBlockStoreVolumeSource = {
    "fsType"?: __cedar::String,
    "partition"?: __cedar::Long,
    "readOnly"?: __cedar::Bool,
    "volumeID": __cedar::String,
  };
  type Affinity = {
    "nodeAffinity"?: NodeAffinity,
    "podAffinity"?: PodAffinity,
    "podAntiAffinity"?: PodAntiAffinity,
  };
  type AppArmorProfile = {
    "localhostProfile"?: __cedar::String,
    "type": __cedar::String,
  };
  type AttachedVolume = {
    "devicePath": __cedar::String,
    "name": __cedar::String,
  };
  type AzureDiskVolumeSource = {
    "cachingMode"?: __cedar::String,
    "diskName": __cedar::String,
    "diskURI": __cedar::String,
    "fsType"?: __cedar::String,
    "kind"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
  };
  type AzureFilePersistentVolumeSource = {
    "readOnly"?: __cedar::Bool,
    "secretName": __cedar::String,
    "secretNamespace"?: __cedar::String,
    "shareName": __cedar::String,
  };
  type AzureFileVolumeSource = {
    "readOnly"?: __cedar::Bool,
    "secretName": __cedar::String,
    "shareName": __cedar::String,
  };
  type CSIPersistentVolumeSource = {
    "controllerExpandSecretRef"?: SecretReference,
    "controllerPublishSecretRef"?: SecretReference,
    "driver": __cedar::String,
    "fsType"?: __cedar::String,
    "nodeExpandSecretRef"?: SecretReference,
    "nodePublishSecretRef"?: SecretReference,
    "nodeStageSecretRef"?: SecretReference,
    "readOnly"?: __cedar::Bool,
    "volumeAttributes"?: Set<meta::v1::KeyValue>,
    "volumeHandle": __cedar::String,
  };
  type CSIVolumeSource = {
    "driver": __cedar::String,
    "fsType"?: __cedar::String,
    "nodePublishSecretRef"?: LocalObjectReference,
    "readOnly"?: __cedar::Bool,
    "volumeAttributes"?: Set<meta::v1::KeyValue>,
  };
  type Capabilities = {
    "add"?: Set<__cedar::String>,
    "drop"?: Set<__cedar::String>,
  };
  type CephFSPersistentVolumeSource = {
    "monitors": Set<__cedar::String>,
    "path"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretFile"?: __cedar::String,
    "secretRef"?: SecretReference,
    "user"?: __cedar::String,
  };
  type CephFSVolumeSource = {
    "monitors": Set<__cedar::String>,
    "path"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretFile"?: __cedar::String,
    "secretRef"?: LocalObjectReference,
    "user"?: __cedar::String,
  };
  type CinderPersistentVolumeSource = {
    "fsType"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: SecretReference,
    "volumeID": __cedar::String,
  };
  type CinderVolumeSource = {
    "fsType"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: LocalObjectReference,
    "volumeID": __cedar::String,
  };
  type ClientIPConfig = {
    "timeoutSeconds"?: __cedar::Long,
  };
  type ClusterTrustBundleProjection = {
    "labelSelector"?: meta::v1::LabelSelector,
    "name"?: __cedar::String,
    "optional"?: __cedar::Bool,
    "path": __cedar::String,
    "signerName"?: __cedar::String,
  };
  type ComponentCondition = {
    "error"?: __cedar::String,
    "message"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type ConfigMapEnvSource = {
    "name"?: __cedar::String,
    "optional"?: __cedar::Bool,
  };
  type ConfigMapKeySelector = {
    "key": __cedar::String,
    "name"?: __cedar::String,
    "optional"?: __cedar::Bool,
  };
  type ConfigMapNodeConfigSource = {
    "kubeletConfigKey": __cedar::String,
    "name": __cedar::String,
    "namespace": __cedar::String,
    "resourceVersion"?: __cedar::String,
    "uid"?: __cedar::String,
  };
  type ConfigMapProjection = {
    "items"?: Set<KeyToPath>,
    "name"?: __cedar::String,
    "optional"?: __cedar::Bool,
  };
  type ConfigMapVolumeSource = {
    "defaultMode"?: __cedar::Long,
    "items"?: Set<KeyToPath>,
    "name"?: __cedar::String,
    "optional"?: __cedar::Bool,
  };
  type Container = {
    "args"?: Set<__cedar::String>,
    "command"?: Set<__cedar::String>,
    "env"?: Set<EnvVar>,
    "envFrom"?: Set<EnvFromSource>,
    "image"?: __cedar::String,
    "imagePullPolicy"?: __cedar::String,
    "lifecycle"?: Lifecycle,
    "livenessProbe"?: Probe,
    "name": __cedar::String,
    "ports"?: Set<ContainerPort>,
    "readinessProbe"?: Probe,
    "resizePolicy"?: Set<ContainerResizePolicy>,
    "resources"?: ResourceRequirements,
    "restartPolicy"?: __cedar::String,
    "securityContext"?: SecurityContext,
    "startupProbe"?: Probe,
    "stdin"?: __cedar::Bool,
    "stdinOnce"?: __cedar::Bool,
    "terminationMessagePath"?: __cedar::String,
    "terminationMessagePolicy"?: __cedar::String,
    "tty"?: __cedar::Bool,
    "volumeDevices"?: Set<VolumeDevice>,
    "volumeMounts"?: Set<VolumeMount>,
    "workingDir"?: __cedar::String,
  };
  type ContainerImage = {
    "names"?: Set<__cedar::String>,
    "sizeBytes"?: __cedar::Long,
  };
  type ContainerPort = {
    "containerPort": __cedar::Long,
    "hostIP"?: __cedar::String,
    "hostPort"?: __cedar::Long,
    "name"?: __cedar::String,
    "protocol"?: __cedar::String,
  };
  type ContainerResizePolicy = {
    "resourceName": __cedar::String,
    "restartPolicy": __cedar::String,
  };
  type ContainerState = {
    "running"?: ContainerStateRunning,
    "terminated"?: ContainerStateTerminated,
    "waiting"?: ContainerStateWaiting,
  };
  type ContainerStateRunning = {
    "startedAt"?: __cedar::String,
  };
  type ContainerStateTerminated = {
    "containerID"?: __cedar::String,
    "exitCode": __cedar::Long,
    "finishedAt"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "signal"?: __cedar::Long,
    "startedAt"?: __cedar::String,
  };
  type ContainerStateWaiting = {
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
  };
  type ContainerStatus = {
    "allocatedResources"?: __cedar::String,
    "allocatedResourcesStatus"?: Set<ResourceStatus>,
    "containerID"?: __cedar::String,
    "image": __cedar::String,
    "imageID": __cedar::String,
    "lastState"?: ContainerState,
    "name": __cedar::String,
    "ready": __cedar::Bool,
    "resources"?: ResourceRequirements,
    "restartCount": __cedar::Long,
    "started"?: __cedar::Bool,
    "state"?: ContainerState,
    "user"?: ContainerUser,
    "volumeMounts"?: Set<VolumeMountStatus>,
  };
  type ContainerUser = {
    "linux"?: LinuxContainerUser,
  };
  type DaemonEndpoint = {
    "Port": __cedar::Long,
  };
  type DownwardAPIProjection = {
    "items"?: Set<DownwardAPIVolumeFile>,
  };
  type DownwardAPIVolumeFile = {
    "fieldRef"?: ObjectFieldSelector,
    "mode"?: __cedar::Long,
    "path": __cedar::String,
    "resourceFieldRef"?: ResourceFieldSelector,
  };
  type DownwardAPIVolumeSource = {
    "defaultMode"?: __cedar::Long,
    "items"?: Set<DownwardAPIVolumeFile>,
  };
  type EmptyDirVolumeSource = {
    "medium"?: __cedar::String,
    "sizeLimit"?: __cedar::String,
  };
  type EndpointAddress = {
    "hostname"?: __cedar::String,
    "ip": __cedar::String,
    "nodeName"?: __cedar::String,
    "targetRef"?: ObjectReference,
  };
  type EndpointPort = {
    "appProtocol"?: __cedar::String,
    "name"?: __cedar::String,
    "port": __cedar::Long,
    "protocol"?: __cedar::String,
  };
  type EndpointSubset = {
    "addresses"?: Set<EndpointAddress>,
    "notReadyAddresses"?: Set<EndpointAddress>,
    "ports"?: Set<EndpointPort>,
  };
  type EnvFromSource = {
    "configMapRef"?: ConfigMapEnvSource,
    "prefix"?: __cedar::String,
    "secretRef"?: SecretEnvSource,
  };
  type EnvVar = {
    "name": __cedar::String,
    "value"?: __cedar::String,
    "valueFrom"?: EnvVarSource,
  };
  type EnvVarSource = {
    "configMapKeyRef"?: ConfigMapKeySelector,
    "fieldRef"?: ObjectFieldSelector,
    "resourceFieldRef"?: ResourceFieldSelector,
    "secretKeyRef"?: SecretKeySelector,
  };
  type EphemeralContainer = {
    "args"?: Set<__cedar::String>,
    "command"?: Set<__cedar::String>,
    "env"?: Set<EnvVar>,
    "envFrom"?: Set<EnvFromSource>,
    "image"?: __cedar::String,
    "imagePullPolicy"?: __cedar::String,
    "lifecycle"?: Lifecycle,
    "livenessProbe"?: Probe,
    "name": __cedar::String,
    "ports"?: Set<ContainerPort>,
    "readinessProbe"?: Probe,
    "resizePolicy"?: Set<ContainerResizePolicy>,
    "resources"?: ResourceRequirements,
    "restartPolicy"?: __cedar::String,
    "securityContext"?: SecurityContext,
    "startupProbe"?: Probe,
    "stdin"?: __cedar::Bool,
    "stdinOnce"?: __cedar::Bool,
    "targetContainerName"?: __cedar::String,
    "terminationMessagePath"?: __cedar::String,
    "terminationMessagePolicy"?: __cedar::String,
    "tty"?: __cedar::Bool,
    "volumeDevices"?: Set<VolumeDevice>,
    "volumeMounts"?: Set<VolumeMount>,
    "workingDir"?: __cedar::String,
  };
  type EphemeralVolumeSource = {
    "volumeClaimTemplate"?: PersistentVolumeClaimTemplate,
  };
  type EventSeries = {
    "count"?: __cedar::Long,
    "lastObservedTime"?: __cedar::String,
  };
  type EventSource = {
    "component"?: __cedar::String,
    "host"?: __cedar::String,
  };
  type ExecAction = {
    "command"?: Set<__cedar::String>,
  };
  type FCVolumeSource = {
    "fsType"?: __cedar::String,
    "lun"?: __cedar::Long,
    "readOnly"?: __cedar::Bool,
    "targetWWNs"?: Set<__cedar::String>,
    "wwids"?: Set<__cedar::String>,
  };
  type FlexPersistentVolumeSource = {
    "driver": __cedar::String,
    "fsType"?: __cedar::String,
    "options"?: Set<meta::v1::KeyValue>,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: SecretReference,
  };
  type FlexVolumeSource = {
    "driver": __cedar::String,
    "fsType"?: __cedar::String,
    "options"?: Set<meta::v1::KeyValue>,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: LocalObjectReference,
  };
  type FlockerVolumeSource = {
    "datasetName"?: __cedar::String,
    "datasetUUID"?: __cedar::String,
  };
  type GCEPersistentDiskVolumeSource = {
    "fsType"?: __cedar::String,
    "partition"?: __cedar::Long,
    "pdName": __cedar::String,
    "readOnly"?: __cedar::Bool,
  };
  type GRPCAction = {
    "port": __cedar::Long,
    "service"?: __cedar::String,
  };
  type GitRepoVolumeSource = {
    "directory"?: __cedar::String,
    "repository": __cedar::String,
    "revision"?: __cedar::String,
  };
  type GlusterfsPersistentVolumeSource = {
    "endpoints": __cedar::String,
    "endpointsNamespace"?: __cedar::String,
    "path": __cedar::String,
    "readOnly"?: __cedar::Bool,
  };
  type GlusterfsVolumeSource = {
    "endpoints": __cedar::String,
    "path": __cedar::String,
    "readOnly"?: __cedar::Bool,
  };
  type HTTPGetAction = {
    "host"?: __cedar::String,
    "httpHeaders"?: Set<HTTPHeader>,
    "path"?: __cedar::String,
    "port": __cedar::String,
    "scheme"?: __cedar::String,
  };
  type HTTPHeader = {
    "name": __cedar::String,
    "value": __cedar::String,
  };
  type HostAlias = {
    "hostnames"?: Set<__cedar::String>,
    "ip": __cedar::String,
  };
  type HostIP = {
    "ip": __cedar::String,
  };
  type HostPathVolumeSource = {
    "path": __cedar::String,
    "type"?: __cedar::String,
  };
  type ISCSIPersistentVolumeSource = {
    "chapAuthDiscovery"?: __cedar::Bool,
    "chapAuthSession"?: __cedar::Bool,
    "fsType"?: __cedar::String,
    "initiatorName"?: __cedar::String,
    "iqn": __cedar::String,
    "iscsiInterface"?: __cedar::String,
    "lun": __cedar::Long,
    "portals"?: Set<__cedar::String>,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: SecretReference,
    "targetPortal": __cedar::String,
  };
  type ISCSIVolumeSource = {
    "chapAuthDiscovery"?: __cedar::Bool,
    "chapAuthSession"?: __cedar::Bool,
    "fsType"?: __cedar::String,
    "initiatorName"?: __cedar::String,
    "iqn": __cedar::String,
    "iscsiInterface"?: __cedar::String,
    "lun": __cedar::Long,
    "portals"?: Set<__cedar::String>,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: LocalObjectReference,
    "targetPortal": __cedar::String,
  };
  type ImageVolumeSource = {
    "pullPolicy"?: __cedar::String,
    "reference"?: __cedar::String,
  };
  type KeyToPath = {
    "key": __cedar::String,
    "mode"?: __cedar::Long,
    "path": __cedar::String,
  };
  type Lifecycle = {
    "postStart"?: LifecycleHandler,
    "preStop"?: LifecycleHandler,
  };
  type LifecycleHandler = {
    "exec"?: ExecAction,
    "httpGet"?: HTTPGetAction,
    "sleep"?: SleepAction,
    "tcpSocket"?: TCPSocketAction,
  };
  type LimitRangeItem = {
    "default"?: __cedar::String,
    "defaultRequest"?: __cedar::String,
    "max"?: __cedar::String,
    "maxLimitRequestRatio"?: __cedar::String,
    "min"?: __cedar::String,
    "type": __cedar::String,
  };
  type LimitRangeSpec = {
    "limits": Set<LimitRangeItem>,
  };
  type LinuxContainerUser = {
    "gid": __cedar::Long,
    "supplementalGroups"?: Set<__cedar::Long>,
    "uid": __cedar::Long,
  };
  type LoadBalancerIngress = {
    "hostname"?: __cedar::String,
    "ip"?: __cedar::String,
    "ipMode"?: __cedar::String,
    "ports"?: Set<PortStatus>,
  };
  type LoadBalancerStatus = {
    "ingress"?: Set<LoadBalancerIngress>,
  };
  type LocalObjectReference = {
    "name"?: __cedar::String,
  };
  type LocalVolumeSource = {
    "fsType"?: __cedar::String,
    "path": __cedar::String,
  };
  type ModifyVolumeStatus = {
    "status": __cedar::String,
    "targetVolumeAttributesClassName"?: __cedar::String,
  };
  type NFSVolumeSource = {
    "path": __cedar::String,
    "readOnly"?: __cedar::Bool,
    "server": __cedar::String,
  };
  type NamespaceCondition = {
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type NamespaceSpec = {
    "finalizers"?: Set<__cedar::String>,
  };
  type NamespaceStatus = {
    "conditions"?: Set<NamespaceCondition>,
    "phase"?: __cedar::String,
  };
  type NodeAddress = {
    "address": __cedar::String,
    "type": __cedar::String,
  };
  type NodeAffinity = {
    "preferredDuringSchedulingIgnoredDuringExecution"?: Set<PreferredSchedulingTerm>,
    "requiredDuringSchedulingIgnoredDuringExecution"?: NodeSelector,
  };
  type NodeCondition = {
    "lastHeartbeatTime"?: __cedar::String,
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type NodeConfigSource = {
    "configMap"?: ConfigMapNodeConfigSource,
  };
  type NodeConfigStatus = {
    "active"?: NodeConfigSource,
    "assigned"?: NodeConfigSource,
    "error"?: __cedar::String,
    "lastKnownGood"?: NodeConfigSource,
  };
  type NodeDaemonEndpoints = {
    "kubeletEndpoint"?: DaemonEndpoint,
  };
  type NodeFeatures = {
    "supplementalGroupsPolicy"?: __cedar::Bool,
  };
  type NodeRuntimeHandler = {
    "features"?: NodeRuntimeHandlerFeatures,
    "name"?: __cedar::String,
  };
  type NodeRuntimeHandlerFeatures = {
    "recursiveReadOnlyMounts"?: __cedar::Bool,
    "userNamespaces"?: __cedar::Bool,
  };
  type NodeSelector = {
    "nodeSelectorTerms": Set<NodeSelectorTerm>,
  };
  type NodeSelectorRequirement = {
    "key": __cedar::String,
    "operator": __cedar::String,
    "values"?: Set<__cedar::String>,
  };
  type NodeSelectorTerm = {
    "matchExpressions"?: Set<NodeSelectorRequirement>,
    "matchFields"?: Set<NodeSelectorRequirement>,
  };
  type NodeSpec = {
    "configSource"?: NodeConfigSource,
    "externalID"?: __cedar::String,
    "podCIDR"?: __cedar::String,
    "podCIDRs"?: Set<__cedar::String>,
    "providerID"?: __cedar::String,
    "taints"?: Set<Taint>,
    "unschedulable"?: __cedar::Bool,
  };
  type NodeStatus = {
    "addresses"?: Set<NodeAddress>,
    "allocatable"?: __cedar::String,
    "capacity"?: __cedar::String,
    "conditions"?: Set<NodeCondition>,
    "config"?: NodeConfigStatus,
    "daemonEndpoints"?: NodeDaemonEndpoints,
    "features"?: NodeFeatures,
    "images"?: Set<ContainerImage>,
    "nodeInfo"?: NodeSystemInfo,
    "phase"?: __cedar::String,
    "runtimeHandlers"?: Set<NodeRuntimeHandler>,
    "volumesAttached"?: Set<AttachedVolume>,
    "volumesInUse"?: Set<__cedar::String>,
  };
  type NodeSystemInfo = {
    "architecture": __cedar::String,
    "bootID": __cedar::String,
    "containerRuntimeVersion": __cedar::String,
    "kernelVersion": __cedar::String,
    "kubeProxyVersion": __cedar::String,
    "kubeletVersion": __cedar::String,
    "machineID": __cedar::String,
    "operatingSystem": __cedar::String,
    "osImage": __cedar::String,
    "systemUUID": __cedar::String,
  };
  type ObjectFieldSelector = {
    "apiVersion"?: __cedar::String,
    "fieldPath": __cedar::String,
  };
  type ObjectReference = {
    "apiVersion"?: __cedar::String,
    "fieldPath"?: __cedar::String,
    "kind"?: __cedar::String,
    "name"?: __cedar::String,
    "namespace"?: __cedar::String,
    "resourceVersion"?: __cedar::String,
    "uid"?: __cedar::String,
  };
  type PersistentVolumeClaimCondition = {
    "lastProbeTime"?: __cedar::String,
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type PersistentVolumeClaimSpec = {
    "accessModes"?: Set<__cedar::String>,
    "dataSource"?: TypedLocalObjectReference,
    "dataSourceRef"?: TypedObjectReference,
    "resources"?: VolumeResourceRequirements,
    "selector"?: meta::v1::LabelSelector,
    "storageClassName"?: __cedar::String,
    "volumeAttributesClassName"?: __cedar::String,
    "volumeMode"?: __cedar::String,
    "volumeName"?: __cedar::String,
  };
  type PersistentVolumeClaimStatus = {
    "accessModes"?: Set<__cedar::String>,
    "allocatedResourceStatuses"?: Set<meta::v1::KeyValue>,
    "allocatedResources"?: __cedar::String,
    "capacity"?: __cedar::String,
    "conditions"?: Set<PersistentVolumeClaimCondition>,
    "currentVolumeAttributesClassName"?: __cedar::String,
    "modifyVolumeStatus"?: ModifyVolumeStatus,
    "phase"?: __cedar::String,
  };
  type PersistentVolumeClaimTemplate = {
    "metadata"?: meta::v1::ObjectMeta,
    "spec": PersistentVolumeClaimSpec,
  };
  type PersistentVolumeClaimVolumeSource = {
    "claimName": __cedar::String,
    "readOnly"?: __cedar::Bool,
  };
  type PersistentVolumeSpec = {
    "accessModes"?: Set<__cedar::String>,
    "awsElasticBlockStore"?: AWSElasticBlockStoreVolumeSource,
    "azureDisk"?: AzureDiskVolumeSource,
    "azureFile"?: AzureFilePersistentVolumeSource,
    "capacity"?: __cedar::String,
    "cephfs"?: CephFSPersistentVolumeSource,
    "cinder"?: CinderPersistentVolumeSource,
    "claimRef"?: ObjectReference,
    "csi"?: CSIPersistentVolumeSource,
    "fc"?: FCVolumeSource,
    "flexVolume"?: FlexPersistentVolumeSource,
    "flocker"?: FlockerVolumeSource,
    "gcePersistentDisk"?: GCEPersistentDiskVolumeSource,
    "glusterfs"?: GlusterfsPersistentVolumeSource,
    "hostPath"?: HostPathVolumeSource,
    "iscsi"?: ISCSIPersistentVolumeSource,
    "local"?: LocalVolumeSource,
    "mountOptions"?: Set<__cedar::String>,
    "nfs"?: NFSVolumeSource,
    "nodeAffinity"?: VolumeNodeAffinity,
    "persistentVolumeReclaimPolicy"?: __cedar::String,
    "photonPersistentDisk"?: PhotonPersistentDiskVolumeSource,
    "portworxVolume"?: PortworxVolumeSource,
    "quobyte"?: QuobyteVolumeSource,
    "rbd"?: RBDPersistentVolumeSource,
    "scaleIO"?: ScaleIOPersistentVolumeSource,
    "storageClassName"?: __cedar::String,
    "storageos"?: StorageOSPersistentVolumeSource,
    "volumeAttributesClassName"?: __cedar::String,
    "volumeMode"?: __cedar::String,
    "vsphereVolume"?: VsphereVirtualDiskVolumeSource,
  };
  type PersistentVolumeStatus = {
    "lastPhaseTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "phase"?: __cedar::String,
    "reason"?: __cedar::String,
  };
  type PhotonPersistentDiskVolumeSource = {
    "fsType"?: __cedar::String,
    "pdID": __cedar::String,
  };
  type PodAffinity = {
    "preferredDuringSchedulingIgnoredDuringExecution"?: Set<WeightedPodAffinityTerm>,
    "requiredDuringSchedulingIgnoredDuringExecution"?: Set<PodAffinityTerm>,
  };
  type PodAffinityTerm = {
    "labelSelector"?: meta::v1::LabelSelector,
    "matchLabelKeys"?: Set<__cedar::String>,
    "mismatchLabelKeys"?: Set<__cedar::String>,
    "namespaceSelector"?: meta::v1::LabelSelector,
    "namespaces"?: Set<__cedar::String>,
    "topologyKey": __cedar::String,
  };
  type PodAntiAffinity = {
    "preferredDuringSchedulingIgnoredDuringExecution"?: Set<WeightedPodAffinityTerm>,
    "requiredDuringSchedulingIgnoredDuringExecution"?: Set<PodAffinityTerm>,
  };
  type PodCondition = {
    "lastProbeTime"?: __cedar::String,
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type PodDNSConfig = {
    "nameservers"?: Set<__cedar::String>,
    "options"?: Set<PodDNSConfigOption>,
    "searches"?: Set<__cedar::String>,
  };
  type PodDNSConfigOption = {
    "name"?: __cedar::String,
    "value"?: __cedar::String,
  };
  type PodIP = {
    "ip": __cedar::String,
  };
  type PodOS = {
    "name": __cedar::String,
  };
  type PodReadinessGate = {
    "conditionType": __cedar::String,
  };
  type PodResourceClaim = {
    "name": __cedar::String,
    "resourceClaimName"?: __cedar::String,
    "resourceClaimTemplateName"?: __cedar::String,
  };
  type PodResourceClaimStatus = {
    "name": __cedar::String,
    "resourceClaimName"?: __cedar::String,
  };
  type PodSchedulingGate = {
    "name": __cedar::String,
  };
  type PodSecurityContext = {
    "appArmorProfile"?: AppArmorProfile,
    "fsGroup"?: __cedar::Long,
    "fsGroupChangePolicy"?: __cedar::String,
    "runAsGroup"?: __cedar::Long,
    "runAsNonRoot"?: __cedar::Bool,
    "runAsUser"?: __cedar::Long,
    "seLinuxOptions"?: SELinuxOptions,
    "seccompProfile"?: SeccompProfile,
    "supplementalGroups"?: Set<__cedar::Long>,
    "supplementalGroupsPolicy"?: __cedar::String,
    "sysctls"?: Set<Sysctl>,
    "windowsOptions"?: WindowsSecurityContextOptions,
  };
  type PodSpec = {
    "activeDeadlineSeconds"?: __cedar::Long,
    "affinity"?: Affinity,
    "automountServiceAccountToken"?: __cedar::Bool,
    "containers": Set<Container>,
    "dnsConfig"?: PodDNSConfig,
    "dnsPolicy"?: __cedar::String,
    "enableServiceLinks"?: __cedar::Bool,
    "ephemeralContainers"?: Set<EphemeralContainer>,
    "hostAliases"?: Set<HostAlias>,
    "hostIPC"?: __cedar::Bool,
    "hostNetwork"?: __cedar::Bool,
    "hostPID"?: __cedar::Bool,
    "hostUsers"?: __cedar::Bool,
    "hostname"?: __cedar::String,
    "imagePullSecrets"?: Set<LocalObjectReference>,
    "initContainers"?: Set<Container>,
    "nodeName"?: __cedar::String,
    "nodeSelector"?: Set<meta::v1::KeyValue>,
    "os"?: PodOS,
    "overhead"?: __cedar::String,
    "preemptionPolicy"?: __cedar::String,
    "priority"?: __cedar::Long,
    "priorityClassName"?: __cedar::String,
    "readinessGates"?: Set<PodReadinessGate>,
    "resourceClaims"?: Set<PodResourceClaim>,
    "restartPolicy"?: __cedar::String,
    "runtimeClassName"?: __cedar::String,
    "schedulerName"?: __cedar::String,
    "schedulingGates"?: Set<PodSchedulingGate>,
    "securityContext"?: PodSecurityContext,
    "serviceAccount"?: __cedar::String,
    "serviceAccountName"?: __cedar::String,
    "setHostnameAsFQDN"?: __cedar::Bool,
    "shareProcessNamespace"?: __cedar::Bool,
    "subdomain"?: __cedar::String,
    "terminationGracePeriodSeconds"?: __cedar::Long,
    "tolerations"?: Set<Toleration>,
    "topologySpreadConstraints"?: Set<TopologySpreadConstraint>,
    "volumes"?: Set<Volume>,
  };
  type PodStatus = {
    "conditions"?: Set<PodCondition>,
    "containerStatuses"?: Set<ContainerStatus>,
    "ephemeralContainerStatuses"?: Set<ContainerStatus>,
    "hostIP"?: __cedar::String,
    "hostIPs"?: Set<HostIP>,
    "initContainerStatuses"?: Set<ContainerStatus>,
    "message"?: __cedar::String,
    "nominatedNodeName"?: __cedar::String,
    "phase"?: __cedar::String,
    "podIP"?: __cedar::String,
    "podIPs"?: Set<PodIP>,
    "qosClass"?: __cedar::String,
    "reason"?: __cedar::String,
    "resize"?: __cedar::String,
    "resourceClaimStatuses"?: Set<PodResourceClaimStatus>,
    "startTime"?: __cedar::String,
  };
  type PodTemplateSpec = {
    "metadata"?: meta::v1::ObjectMeta,
    "spec"?: PodSpec,
  };
  type PortStatus = {
    "error"?: __cedar::String,
    "port": __cedar::Long,
    "protocol": __cedar::String,
  };
  type PortworxVolumeSource = {
    "fsType"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "volumeID": __cedar::String,
  };
  type PreferredSchedulingTerm = {
    "preference": NodeSelectorTerm,
    "weight": __cedar::Long,
  };
  type Probe = {
    "exec"?: ExecAction,
    "failureThreshold"?: __cedar::Long,
    "grpc"?: GRPCAction,
    "httpGet"?: HTTPGetAction,
    "initialDelaySeconds"?: __cedar::Long,
    "periodSeconds"?: __cedar::Long,
    "successThreshold"?: __cedar::Long,
    "tcpSocket"?: TCPSocketAction,
    "terminationGracePeriodSeconds"?: __cedar::Long,
    "timeoutSeconds"?: __cedar::Long,
  };
  type ProjectedVolumeSource = {
    "defaultMode"?: __cedar::Long,
    "sources"?: Set<VolumeProjection>,
  };
  type QuobyteVolumeSource = {
    "group"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "registry": __cedar::String,
    "tenant"?: __cedar::String,
    "user"?: __cedar::String,
    "volume": __cedar::String,
  };
  type RBDPersistentVolumeSource = {
    "fsType"?: __cedar::String,
    "image": __cedar::String,
    "keyring"?: __cedar::String,
    "monitors": Set<__cedar::String>,
    "pool"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: SecretReference,
    "user"?: __cedar::String,
  };
  type RBDVolumeSource = {
    "fsType"?: __cedar::String,
    "image": __cedar::String,
    "keyring"?: __cedar::String,
    "monitors": Set<__cedar::String>,
    "pool"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: LocalObjectReference,
    "user"?: __cedar::String,
  };
  type ReplicationControllerCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type ReplicationControllerSpec = {
    "minReadySeconds"?: __cedar::Long,
    "replicas"?: __cedar::Long,
    "selector"?: Set<meta::v1::KeyValue>,
    "template"?: PodTemplateSpec,
  };
  type ReplicationControllerStatus = {
    "availableReplicas"?: __cedar::Long,
    "conditions"?: Set<ReplicationControllerCondition>,
    "fullyLabeledReplicas"?: __cedar::Long,
    "observedGeneration"?: __cedar::Long,
    "readyReplicas"?: __cedar::Long,
    "replicas": __cedar::Long,
  };
  type ResourceClaim = {
    "name": __cedar::String,
    "request"?: __cedar::String,
  };
  type ResourceFieldSelector = {
    "containerName"?: __cedar::String,
    "divisor"?: __cedar::String,
    "resource": __cedar::String,
  };
  type ResourceHealth = {
    "health"?: __cedar::String,
    "resourceID": __cedar::String,
  };
  type ResourceQuotaSpec = {
    "hard"?: __cedar::String,
    "scopeSelector"?: ScopeSelector,
    "scopes"?: Set<__cedar::String>,
  };
  type ResourceQuotaStatus = {
    "hard"?: __cedar::String,
    "used"?: __cedar::String,
  };
  type ResourceRequirements = {
    "claims"?: Set<ResourceClaim>,
    "limits"?: __cedar::String,
    "requests"?: __cedar::String,
  };
  type ResourceStatus = {
    "name": __cedar::String,
    "resources"?: Set<ResourceHealth>,
  };
  type SELinuxOptions = {
    "level"?: __cedar::String,
    "role"?: __cedar::String,
    "type"?: __cedar::String,
    "user"?: __cedar::String,
  };
  type ScaleIOPersistentVolumeSource = {
    "fsType"?: __cedar::String,
    "gateway": __cedar::String,
    "protectionDomain"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretRef": SecretReference,
    "sslEnabled"?: __cedar::Bool,
    "storageMode"?: __cedar::String,
    "storagePool"?: __cedar::String,
    "system": __cedar::String,
    "volumeName"?: __cedar::String,
  };
  type ScaleIOVolumeSource = {
    "fsType"?: __cedar::String,
    "gateway": __cedar::String,
    "protectionDomain"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretRef": LocalObjectReference,
    "sslEnabled"?: __cedar::Bool,
    "storageMode"?: __cedar::String,
    "storagePool"?: __cedar::String,
    "system": __cedar::String,
    "volumeName"?: __cedar::String,
  };
  type ScopeSelector = {
    "matchExpressions"?: Set<ScopedResourceSelectorRequirement>,
  };
  type ScopedResourceSelectorRequirement = {
    "operator": __cedar::String,
    "scopeName": __cedar::String,
    "values"?: Set<__cedar::String>,
  };
  type SeccompProfile = {
    "localhostProfile"?: __cedar::String,
    "type": __cedar::String,
  };
  type SecretEnvSource = {
    "name"?: __cedar::String,
    "optional"?: __cedar::Bool,
  };
  type SecretKeySelector = {
    "key": __cedar::String,
    "name"?: __cedar::String,
    "optional"?: __cedar::Bool,
  };
  type SecretProjection = {
    "items"?: Set<KeyToPath>,
    "name"?: __cedar::String,
    "optional"?: __cedar::Bool,
  };
  type SecretReference = {
    "name"?: __cedar::String,
    "namespace"?: __cedar::String,
  };
  type SecretVolumeSource = {
    "defaultMode"?: __cedar::Long,
    "items"?: Set<KeyToPath>,
    "optional"?: __cedar::Bool,
    "secretName"?: __cedar::String,
  };
  type SecurityContext = {
    "allowPrivilegeEscalation"?: __cedar::Bool,
    "appArmorProfile"?: AppArmorProfile,
    "capabilities"?: Capabilities,
    "privileged"?: __cedar::Bool,
    "procMount"?: __cedar::String,
    "readOnlyRootFilesystem"?: __cedar::Bool,
    "runAsGroup"?: __cedar::Long,
    "runAsNonRoot"?: __cedar::Bool,
    "runAsUser"?: __cedar::Long,
    "seLinuxOptions"?: SELinuxOptions,
    "seccompProfile"?: SeccompProfile,
    "windowsOptions"?: WindowsSecurityContextOptions,
  };
  type ServiceAccountTokenProjection = {
    "audience"?: __cedar::String,
    "expirationSeconds"?: __cedar::Long,
    "path": __cedar::String,
  };
  type ServicePort = {
    "appProtocol"?: __cedar::String,
    "name"?: __cedar::String,
    "nodePort"?: __cedar::Long,
    "port": __cedar::Long,
    "protocol"?: __cedar::String,
    "targetPort"?: __cedar::String,
  };
  type ServiceSpec = {
    "allocateLoadBalancerNodePorts"?: __cedar::Bool,
    "clusterIP"?: __cedar::String,
    "clusterIPs"?: Set<__cedar::String>,
    "externalIPs"?: Set<__cedar::String>,
    "externalName"?: __cedar::String,
    "externalTrafficPolicy"?: __cedar::String,
    "healthCheckNodePort"?: __cedar::Long,
    "internalTrafficPolicy"?: __cedar::String,
    "ipFamilies"?: Set<__cedar::String>,
    "ipFamilyPolicy"?: __cedar::String,
    "loadBalancerClass"?: __cedar::String,
    "loadBalancerIP"?: __cedar::String,
    "loadBalancerSourceRanges"?: Set<__cedar::String>,
    "ports"?: Set<ServicePort>,
    "publishNotReadyAddresses"?: __cedar::Bool,
    "selector"?: Set<meta::v1::KeyValue>,
    "sessionAffinity"?: __cedar::String,
    "sessionAffinityConfig"?: SessionAffinityConfig,
    "trafficDistribution"?: __cedar::String,
    "type"?: __cedar::String,
  };
  type ServiceStatus = {
    "conditions"?: Set<meta::v1::Condition>,
    "loadBalancer"?: LoadBalancerStatus,
  };
  type SessionAffinityConfig = {
    "clientIP"?: ClientIPConfig,
  };
  type SleepAction = {
    "seconds": __cedar::Long,
  };
  type StorageOSPersistentVolumeSource = {
    "fsType"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: ObjectReference,
    "volumeName"?: __cedar::String,
    "volumeNamespace"?: __cedar::String,
  };
  type StorageOSVolumeSource = {
    "fsType"?: __cedar::String,
    "readOnly"?: __cedar::Bool,
    "secretRef"?: LocalObjectReference,
    "volumeName"?: __cedar::String,
    "volumeNamespace"?: __cedar::String,
  };
  type Sysctl = {
    "name": __cedar::String,
    "value": __cedar::String,
  };
  type TCPSocketAction = {
    "host"?: __cedar::String,
    "port": __cedar::String,
  };
  type Taint = {
    "effect": __cedar::String,
    "key": __cedar::String,
    "timeAdded"?: __cedar::String,
    "value"?: __cedar::String,
  };
  type Toleration = {
    "effect"?: __cedar::String,
    "key"?: __cedar::String,
    "operator"?: __cedar::String,
    "tolerationSeconds"?: __cedar::Long,
    "value"?: __cedar::String,
  };
  type TopologySelectorLabelRequirement = {
    "key": __cedar::String,
    "values": Set<__cedar::String>,
  };
  type TopologySelectorTerm = {
    "matchLabelExpressions"?: Set<TopologySelectorLabelRequirement>,
  };
  type TopologySpreadConstraint = {
    "labelSelector"?: meta::v1::LabelSelector,
    "matchLabelKeys"?: Set<__cedar::String>,
    "maxSkew": __cedar::Long,
    "minDomains"?: __cedar::Long,
    "nodeAffinityPolicy"?: __cedar::String,
    "nodeTaintsPolicy"?: __cedar::String,
    "topologyKey": __cedar::String,
    "whenUnsatisfiable": __cedar::String,
  };
  type TypedLocalObjectReference = {
    "apiGroup"?: __cedar::String,
    "kind": __cedar::String,
    "name": __cedar::String,
  };
  type TypedObjectReference = {
    "apiGroup"?: __cedar::String,
    "kind": __cedar::String,
    "name": __cedar::String,
    "namespace"?: __cedar::String,
  };
  type Volume = {
    "awsElasticBlockStore"?: AWSElasticBlockStoreVolumeSource,
    "azureDisk"?: AzureDiskVolumeSource,
    "azureFile"?: AzureFileVolumeSource,
    "cephfs"?: CephFSVolumeSource,
    "cinder"?: CinderVolumeSource,
    "configMap"?: ConfigMapVolumeSource,
    "csi"?: CSIVolumeSource,
    "downwardAPI"?: DownwardAPIVolumeSource,
    "emptyDir"?: EmptyDirVolumeSource,
    "ephemeral"?: EphemeralVolumeSource,
    "fc"?: FCVolumeSource,
    "flexVolume"?: FlexVolumeSource,
    "flocker"?: FlockerVolumeSource,
    "gcePersistentDisk"?: GCEPersistentDiskVolumeSource,
    "gitRepo"?: GitRepoVolumeSource,
    "glusterfs"?: GlusterfsVolumeSource,
    "hostPath"?: HostPathVolumeSource,
    "image"?: ImageVolumeSource,
    "iscsi"?: ISCSIVolumeSource,
    "name": __cedar::String,
    "nfs"?: NFSVolumeSource,
    "persistentVolumeClaim"?: PersistentVolumeClaimVolumeSource,
    "photonPersistentDisk"?: PhotonPersistentDiskVolumeSource,
    "portworxVolume"?: PortworxVolumeSource,
    "projected"?: ProjectedVolumeSource,
    "quobyte"?: QuobyteVolumeSource,
    "rbd"?: RBDVolumeSource,
    "scaleIO"?: ScaleIOVolumeSource,
    "secret"?: SecretVolumeSource,
    "storageos"?: StorageOSVolumeSource,
    "vsphereVolume"?: VsphereVirtualDiskVolumeSource,
  };
  type VolumeDevice = {
    "devicePath": __cedar::String,
    "name": __cedar::String,
  };
  type VolumeMount = {
    "mountPath": __cedar::String,
    "mountPropagation"?: __cedar::String,
    "name": __cedar::String,
    "readOnly"?: __cedar::Bool,
    "recursiveReadOnly"?: __cedar::String,
    "subPath"?: __cedar::String,
    "subPathExpr"?: __cedar::String,
  };
  type VolumeMountStatus = {
    "mountPath": __cedar::String,
    "name": __cedar::String,
    "readOnly"?: __cedar::Bool,
    "recursiveReadOnly"?: __cedar::String,
  };
  type VolumeNodeAffinity = {
    "required"?: NodeSelector,
  };
  type VolumeProjection = {
    "clusterTrustBundle"?: ClusterTrustBundleProjection,
    "configMap"?: ConfigMapProjection,
    "downwardAPI"?: DownwardAPIProjection,
    "secret"?: SecretProjection,
    "serviceAccountToken"?: ServiceAccountTokenProjection,
  };
  type VolumeResourceRequirements = {
    "limits"?: __cedar::String,
    "requests"?: __cedar::String,
  };
  type VsphereVirtualDiskVolumeSource = {
    "fsType"?: __cedar::String,
    "storagePolicyID"?: __cedar::String,
    "storagePolicyName"?: __cedar::String,
    "volumePath": __cedar::String,
  };
  type WeightedPodAffinityTerm = {
    "podAffinityTerm": PodAffinityTerm,
    "weight": __cedar::Long,
  };
  type WindowsSecurityContextOptions = {
    "gmsaCredentialSpec"?: __cedar::String,
    "gmsaCredentialSpecName"?: __cedar::String,
    "hostProcess"?: __cedar::Bool,
    "runAsUserName"?: __cedar::String,
  };
  entity Binding = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "target": ObjectReference,
  };
  entity ComponentStatus = {
    "apiVersion"?: __cedar::String,
    "conditions"?: Set<ComponentCondition>,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
  };
  entity ConfigMap = {
    "apiVersion"?: __cedar::String,
    "binaryData"?: Set<meta::v1::KeyValue>,
    "data"?: Set<meta::v1::KeyValue>,
    "immutable"?: __cedar::Bool,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ConfigMap,
  };
  entity Endpoints = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Endpoints,
    "subsets"?: Set<EndpointSubset>,
  };
  entity Event = {
    "action"?: __cedar::String,
    "apiVersion"?: __cedar::String,
    "count"?: __cedar::Long,
    "eventTime"?: __cedar::String,
    "firstTimestamp"?: __cedar::String,
    "involvedObject": ObjectReference,
    "kind"?: __cedar::String,
    "lastTimestamp"?: __cedar::String,
    "message"?: __cedar::String,
    "metadata": meta::v1::ObjectMeta,
    "oldObject"?: Event,
    "reason"?: __cedar::String,
    "related"?: ObjectReference,
    "reportingComponent"?: __cedar::String,
    "reportingInstance"?: __cedar::String,
    "series"?: EventSeries,
    "source"?: EventSource,
    "type"?: __cedar::String,
  };
  entity LimitRange = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: LimitRange,
    "spec"?: LimitRangeSpec,
  };
  entity Namespace = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Namespace,
    "spec"?: NamespaceSpec,
    "status"?: NamespaceStatus,
  };
  entity Node = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Node,
    "spec"?: NodeSpec,
    "status"?: NodeStatus,
  };
  entity NodeProxyOptions = {
    "apiVersion": __cedar::String,
    "kind": __cedar::String,
    "path": __cedar::String,
  };
  entity PersistentVolume = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: PersistentVolume,
    "spec"?: PersistentVolumeSpec,
    "status"?: PersistentVolumeStatus,
  };
  entity PersistentVolumeClaim = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: PersistentVolumeClaim,
    "spec"?: PersistentVolumeClaimSpec,
    "status"?: PersistentVolumeClaimStatus,
  };
  entity Pod = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Pod,
    "spec"?: PodSpec,
    "status"?: PodStatus,
  };
  entity PodAttachOptions = {
    "apiVersion": __cedar::String,
    "command": Set<__cedar::String>,
    "container": __cedar::String,
    "kind": __cedar::String,
    "stderr": __cedar::Bool,
    "stdin": __cedar::Bool,
    "stdout": __cedar::Bool,
    "tty": __cedar::Bool,
  };
  entity PodExecOptions = {
    "apiVersion": __cedar::String,
    "command": Set<__cedar::String>,
    "container": __cedar::String,
    "kind": __cedar::String,
    "stderr": __cedar::Bool,
    "stdin": __cedar::Bool,
    "stdout": __cedar::Bool,
    "tty": __cedar::Bool,
  };
  entity PodPortForwardOptions = {
    "apiVersion": __cedar::String,
    "kind": __cedar::String,
    "ports"?: Set<__cedar::String>,
  };
  entity PodProxyOptions = {
    "apiVersion": __cedar::String,
    "kind": __cedar::String,
    "path": __cedar::String,
  };
  entity PodTemplate = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: PodTemplate,
    "template"?: PodTemplateSpec,
  };
  entity ReplicationController = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ReplicationController,
    "spec"?: ReplicationControllerSpec,
    "status"?: ReplicationControllerStatus,
  };
  entity ResourceQuota = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ResourceQuota,
    "spec"?: ResourceQuotaSpec,
    "status"?: ResourceQuotaStatus,
  };
  entity Secret = {
    "apiVersion"?: __cedar::String,
    "data"?: Set<meta::v1::KeyValue>,
    "immutable"?: __cedar::Bool,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Secret,
    "stringData"?: Set<meta::v1::KeyValue>,
    "type"?: __cedar::String,
  };
  entity Service = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Service,
    "spec"?: ServiceSpec,
    "status"?: ServiceStatus,
  };
  entity ServiceAccount = {
    "apiVersion"?: __cedar::String,
    "automountServiceAccountToken"?: __cedar::Bool,
    "imagePullSecrets"?: Set<LocalObjectReference>,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ServiceAccount,
    "secrets"?: Set<ObjectReference>,
  };
  entity ServiceProxyOptions = {
    "apiVersion": __cedar::String,
    "kind": __cedar::String,
    "path": __cedar::String,
  };
}
namespace discovery::v1 {
  type Endpoint = {
    "addresses": Set<__cedar::String>,
    "conditions"?: EndpointConditions,
    "deprecatedTopology"?: Set<meta::v1::KeyValue>,
    "hints"?: EndpointHints,
    "hostname"?: __cedar::String,
    "nodeName"?: __cedar::String,
    "targetRef"?: core::v1::ObjectReference,
    "zone"?: __cedar::String,
  };
  type EndpointConditions = {
    "ready"?: __cedar::Bool,
    "serving"?: __cedar::Bool,
    "terminating"?: __cedar::Bool,
  };
  type EndpointHints = {
    "forZones"?: Set<ForZone>,
  };
  type EndpointPort = {
    "appProtocol"?: __cedar::String,
    "name"?: __cedar::String,
    "port"?: __cedar::Long,
    "protocol"?: __cedar::String,
  };
  type ForZone = {
    "name": __cedar::String,
  };
  entity EndpointSlice = {
    "addressType": __cedar::String,
    "apiVersion"?: __cedar::String,
    "endpoints": Set<Endpoint>,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: EndpointSlice,
    "ports"?: Set<EndpointPort>,
  };
}
namespace events::v1 {
  type EventSeries = {
    "count": __cedar::Long,
    "lastObservedTime": __cedar::String,
  };
  entity Event = {
    "action"?: __cedar::String,
    "apiVersion"?: __cedar::String,
    "deprecatedCount"?: __cedar::Long,
    "deprecatedFirstTimestamp"?: __cedar::String,
    "deprecatedLastTimestamp"?: __cedar::String,
    "deprecatedSource"?: core::v1::EventSource,
    "eventTime": __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "note"?: __cedar::String,
    "oldObject"?: Event,
    "reason"?: __cedar::String,
    "regarding"?: core::v1::ObjectReference,
    "related"?: core::v1::ObjectReference,
    "reportingController"?: __cedar::String,
    "reportingInstance"?: __cedar::String,
    "series"?: EventSeries,
    "type"?: __cedar::String,
  };
}
namespace flowcontrol::v1 {
  type ExemptPriorityLevelConfiguration = {
    "lendablePercent"?: __cedar::Long,
    "nominalConcurrencyShares"?: __cedar::Long,
  };
  type FlowDistinguisherMethod = {
    "type": __cedar::String,
  };
  type FlowSchemaCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status"?: __cedar::String,
    "type"?: __cedar::String,
  };
  type FlowSchemaSpec = {
    "distinguisherMethod"?: FlowDistinguisherMethod,
    "matchingPrecedence"?: __cedar::Long,
    "priorityLevelConfiguration": PriorityLevelConfigurationReference,
    "rules"?: Set<PolicyRulesWithSubjects>,
  };
  type FlowSchemaStatus = {
    "conditions"?: Set<FlowSchemaCondition>,
  };
  type GroupSubject = {
    "name": __cedar::String,
  };
  type LimitResponse = {
    "queuing"?: QueuingConfiguration,
    "type": __cedar::String,
  };
  type LimitedPriorityLevelConfiguration = {
    "borrowingLimitPercent"?: __cedar::Long,
    "lendablePercent"?: __cedar::Long,
    "limitResponse"?: LimitResponse,
    "nominalConcurrencyShares"?: __cedar::Long,
  };
  type NonResourcePolicyRule = {
    "nonResourceURLs": Set<__cedar::String>,
    "verbs": Set<__cedar::String>,
  };
  type PolicyRulesWithSubjects = {
    "nonResourceRules"?: Set<NonResourcePolicyRule>,
    "resourceRules"?: Set<ResourcePolicyRule>,
    "subjects": Set<Subject>,
  };
  type PriorityLevelConfigurationCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status"?: __cedar::String,
    "type"?: __cedar::String,
  };
  type PriorityLevelConfigurationReference = {
    "name": __cedar::String,
  };
  type PriorityLevelConfigurationSpec = {
    "exempt"?: ExemptPriorityLevelConfiguration,
    "limited"?: LimitedPriorityLevelConfiguration,
    "type": __cedar::String,
  };
  type PriorityLevelConfigurationStatus = {
    "conditions"?: Set<PriorityLevelConfigurationCondition>,
  };
  type QueuingConfiguration = {
    "handSize"?: __cedar::Long,
    "queueLengthLimit"?: __cedar::Long,
    "queues"?: __cedar::Long,
  };
  type ResourcePolicyRule = {
    "apiGroups": Set<__cedar::String>,
    "clusterScope"?: __cedar::Bool,
    "namespaces"?: Set<__cedar::String>,
    "resources": Set<__cedar::String>,
    "verbs": Set<__cedar::String>,
  };
  type ServiceAccountSubject = {
    "name": __cedar::String,
    "namespace": __cedar::String,
  };
  type Subject = {
    "group"?: GroupSubject,
    "kind": __cedar::String,
    "serviceAccount"?: ServiceAccountSubject,
    "user"?: UserSubject,
  };
  type UserSubject = {
    "name": __cedar::String,
  };
  entity FlowSchema = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: FlowSchema,
    "spec"?: FlowSchemaSpec,
    "status"?: FlowSchemaStatus,
  };
  entity PriorityLevelConfiguration = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: PriorityLevelConfiguration,
    "spec"?: PriorityLevelConfigurationSpec,
    "status"?: PriorityLevelConfigurationStatus,
  };
}
namespace meta::v1 {
  type APIResource = {
    "categories"?: Set<__cedar::String>,
    "group"?: __cedar::String,
    "kind": __cedar::String,
    "name": __cedar::String,
    "namespaced": __cedar::Bool,
    "shortNames"?: Set<__cedar::String>,
    "singularName": __cedar::String,
    "storageVersionHash"?: __cedar::String,
    "verbs": Set<__cedar::String>,
    "version"?: __cedar::String,
  };
  type APIResourceList = {
    "apiVersion"?: __cedar::String,
    "groupVersion": __cedar::String,
    "kind"?: __cedar::String,
    "resources": Set<APIResource>,
  };
  type Condition = {
    "lastTransitionTime": __cedar::String,
    "message": __cedar::String,
    "observedGeneration"?: __cedar::Long,
    "reason": __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type DeleteOptions = {
    "apiVersion"?: __cedar::String,
    "dryRun"?: Set<__cedar::String>,
    "gracePeriodSeconds"?: __cedar::Long,
    "kind"?: __cedar::String,
    "orphanDependents"?: __cedar::Bool,
    "preconditions"?: Preconditions,
    "propagationPolicy"?: __cedar::String,
  };
  type FieldSelectorRequirement = {
    "key": __cedar::String,
    "operator": __cedar::String,
    "values"?: Set<__cedar::String>,
  };
  type FieldsV1 = {
  };
  type KeyValue = {
    "key": __cedar::String,
    "value": __cedar::String,
  };
  type KeyValueStringSlice = {
    "key": __cedar::String,
    "value": Set<__cedar::String>,
  };
  type LabelSelector = {
    "matchExpressions"?: Set<LabelSelectorRequirement>,
    "matchLabels"?: Set<KeyValue>,
  };
  type LabelSelectorRequirement = {
    "key": __cedar::String,
    "operator": __cedar::String,
    "values"?: Set<__cedar::String>,
  };
  type ListMeta = {
    "continue"?: __cedar::String,
    "remainingItemCount"?: __cedar::Long,
    "resourceVersion"?: __cedar::String,
    "selfLink"?: __cedar::String,
  };
  type ManagedFieldsEntry = {
    "apiVersion"?: __cedar::String,
    "fieldsType"?: __cedar::String,
    "fieldsV1"?: FieldsV1,
    "manager"?: __cedar::String,
    "operation"?: __cedar::String,
    "subresource"?: __cedar::String,
    "time"?: __cedar::String,
  };
  type ObjectMeta = {
    "annotations"?: Set<KeyValue>,
    "creationTimestamp"?: __cedar::String,
    "deletionGracePeriodSeconds"?: __cedar::Long,
    "deletionTimestamp"?: __cedar::String,
    "finalizers"?: Set<__cedar::String>,
    "generateName"?: __cedar::String,
    "generation"?: __cedar::Long,
    "labels"?: Set<KeyValue>,
    "managedFields"?: Set<ManagedFieldsEntry>,
    "name"?: __cedar::String,
    "namespace"?: __cedar::String,
    "ownerReferences"?: Set<OwnerReference>,
    "resourceVersion"?: __cedar::String,
    "selfLink"?: __cedar::String,
    "uid"?: __cedar::String,
  };
  type OwnerReference = {
    "apiVersion": __cedar::String,
    "blockOwnerDeletion"?: __cedar::Bool,
    "controller"?: __cedar::Bool,
    "kind": __cedar::String,
    "name": __cedar::String,
    "uid": __cedar::String,
  };
  type Patch = {
  };
  type Preconditions = {
    "resourceVersion"?: __cedar::String,
    "uid"?: __cedar::String,
  };
  type Status = {
    "apiVersion"?: __cedar::String,
    "code"?: __cedar::Long,
    "details"?: StatusDetails,
    "kind"?: __cedar::String,
    "message"?: __cedar::String,
    "metadata"?: ListMeta,
    "reason"?: __cedar::String,
    "status"?: __cedar::String,
  };
  type StatusCause = {
    "field"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
  };
  type StatusDetails = {
    "causes"?: Set<StatusCause>,
    "group"?: __cedar::String,
    "kind"?: __cedar::String,
    "name"?: __cedar::String,
    "retryAfterSeconds"?: __cedar::Long,
    "uid"?: __cedar::String,
  };
  type WatchEvent = {
    "object": __cedar::String,
    "type": __cedar::String,
  };
}
namespace networking::v1 {
  type HTTPIngressPath = {
    "backend": IngressBackend,
    "path"?: __cedar::String,
    "pathType": __cedar::String,
  };
  type HTTPIngressRuleValue = {
    "paths": Set<HTTPIngressPath>,
  };
  type IPBlock = {
    "cidr": __cedar::String,
    "except"?: Set<__cedar::String>,
  };
  type IngressBackend = {
    "resource"?: core::v1::TypedLocalObjectReference,
    "service"?: IngressServiceBackend,
  };
  type IngressClassParametersReference = {
    "apiGroup"?: __cedar::String,
    "kind": __cedar::String,
    "name": __cedar::String,
    "namespace"?: __cedar::String,
    "scope"?: __cedar::String,
  };
  type IngressClassSpec = {
    "controller"?: __cedar::String,
    "parameters"?: IngressClassParametersReference,
  };
  type IngressLoadBalancerIngress = {
    "hostname"?: __cedar::String,
    "ip"?: __cedar::String,
    "ports"?: Set<IngressPortStatus>,
  };
  type IngressLoadBalancerStatus = {
    "ingress"?: Set<IngressLoadBalancerIngress>,
  };
  type IngressPortStatus = {
    "error"?: __cedar::String,
    "port": __cedar::Long,
    "protocol": __cedar::String,
  };
  type IngressRule = {
    "host"?: __cedar::String,
  };
  type IngressServiceBackend = {
    "name": __cedar::String,
    "port"?: ServiceBackendPort,
  };
  type IngressSpec = {
    "defaultBackend"?: IngressBackend,
    "ingressClassName"?: __cedar::String,
    "rules"?: Set<IngressRule>,
    "tls"?: Set<IngressTLS>,
  };
  type IngressStatus = {
    "loadBalancer"?: IngressLoadBalancerStatus,
  };
  type IngressTLS = {
    "hosts"?: Set<__cedar::String>,
    "secretName"?: __cedar::String,
  };
  type NetworkPolicyEgressRule = {
    "ports"?: Set<NetworkPolicyPort>,
    "to"?: Set<NetworkPolicyPeer>,
  };
  type NetworkPolicyIngressRule = {
    "from"?: Set<NetworkPolicyPeer>,
    "ports"?: Set<NetworkPolicyPort>,
  };
  type NetworkPolicyPeer = {
    "ipBlock"?: IPBlock,
    "namespaceSelector"?: meta::v1::LabelSelector,
    "podSelector"?: meta::v1::LabelSelector,
  };
  type NetworkPolicyPort = {
    "endPort"?: __cedar::Long,
    "port"?: __cedar::String,
    "protocol"?: __cedar::String,
  };
  type NetworkPolicySpec = {
    "egress"?: Set<NetworkPolicyEgressRule>,
    "ingress"?: Set<NetworkPolicyIngressRule>,
    "podSelector": meta::v1::LabelSelector,
    "policyTypes"?: Set<__cedar::String>,
  };
  type ServiceBackendPort = {
    "name"?: __cedar::String,
    "number"?: __cedar::Long,
  };
  entity Ingress = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Ingress,
    "spec"?: IngressSpec,
    "status"?: IngressStatus,
  };
  entity IngressClass = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: IngressClass,
    "spec"?: IngressClassSpec,
  };
  entity NetworkPolicy = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: NetworkPolicy,
    "spec"?: NetworkPolicySpec,
  };
}
namespace node::v1 {
  type Overhead = {
    "podFixed"?: __cedar::String,
  };
  type Scheduling = {
    "nodeSelector"?: Set<meta::v1::KeyValue>,
    "tolerations"?: Set<core::v1::Toleration>,
  };
  entity RuntimeClass = {
    "apiVersion"?: __cedar::String,
    "handler": __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: RuntimeClass,
    "overhead"?: Overhead,
    "scheduling"?: Scheduling,
  };
}
namespace policy::v1 {
  type PodDisruptionBudgetSpec = {
    "maxUnavailable"?: __cedar::String,
    "minAvailable"?: __cedar::String,
    "selector"?: meta::v1::LabelSelector,
    "unhealthyPodEvictionPolicy"?: __cedar::String,
  };
  type PodDisruptionBudgetStatus = {
    "conditions"?: Set<meta::v1::Condition>,
    "currentHealthy": __cedar::Long,
    "desiredHealthy": __cedar::Long,
    "disruptedPods"?: __cedar::String,
    "disruptionsAllowed": __cedar::Long,
    "expectedPods": __cedar::Long,
    "observedGeneration"?: __cedar::Long,
  };
  entity Eviction = {
    "apiVersion"?: __cedar::String,
    "deleteOptions"?: meta::v1::DeleteOptions,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
  };
  entity PodDisruptionBudget = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: PodDisruptionBudget,
    "spec"?: PodDisruptionBudgetSpec,
    "status"?: PodDisruptionBudgetStatus,
  };
}
namespace rbac::v1 {
  type AggregationRule = {
    "clusterRoleSelectors"?: Set<meta::v1::LabelSelector>,
  };
  type PolicyRule = {
    "apiGroups"?: Set<__cedar::String>,
    "nonResourceURLs"?: Set<__cedar::String>,
    "resourceNames"?: Set<__cedar::String>,
    "resources"?: Set<__cedar::String>,
    "verbs": Set<__cedar::String>,
  };
  type RoleRef = {
    "apiGroup": __cedar::String,
    "kind": __cedar::String,
    "name": __cedar::String,
  };
  type Subject = {
    "apiGroup"?: __cedar::String,
    "kind": __cedar::String,
    "name": __cedar::String,
    "namespace"?: __cedar::String,
  };
  entity ClusterRole = {
    "aggregationRule"?: AggregationRule,
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ClusterRole,
    "rules"?: Set<PolicyRule>,
  };
  entity ClusterRoleBinding = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: ClusterRoleBinding,
    "roleRef": RoleRef,
    "subjects"?: Set<Subject>,
  };
  entity Role = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Role,
    "rules"?: Set<PolicyRule>,
  };
  entity RoleBinding = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: RoleBinding,
    "roleRef": RoleRef,
    "subjects"?: Set<Subject>,
  };
}
namespace scheduling::v1 {
  entity PriorityClass = {
    "apiVersion"?: __cedar::String,
    "description"?: __cedar::String,
    "globalDefault"?: __cedar::Bool,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: PriorityClass,
    "preemptionPolicy"?: __cedar::String,
    "value": __cedar::Long,
  };
}
namespace storage::v1 {
  type CSIDriverSpec = {
    "attachRequired"?: __cedar::Bool,
    "fsGroupPolicy"?: __cedar::String,
    "podInfoOnMount"?: __cedar::Bool,
    "requiresRepublish"?: __cedar::Bool,
    "seLinuxMount"?: __cedar::Bool,
    "storageCapacity"?: __cedar::Bool,
    "tokenRequests"?: Set<TokenRequest>,
    "volumeLifecycleModes"?: Set<__cedar::String>,
  };
  type CSINodeDriver = {
    "allocatable"?: VolumeNodeResources,
    "name": __cedar::String,
    "nodeID": __cedar::String,
    "topologyKeys"?: Set<__cedar::String>,
  };
  type CSINodeSpec = {
    "drivers": Set<CSINodeDriver>,
  };
  type TokenRequest = {
    "audience": __cedar::String,
    "expirationSeconds"?: __cedar::Long,
  };
  type VolumeAttachmentSource = {
    "inlineVolumeSpec"?: core::v1::PersistentVolumeSpec,
    "persistentVolumeName"?: __cedar::String,
  };
  type VolumeAttachmentSpec = {
    "attacher": __cedar::String,
    "nodeName": __cedar::String,
    "source": VolumeAttachmentSource,
  };
  type VolumeAttachmentStatus = {
    "attachError"?: VolumeError,
    "attached": __cedar::Bool,
    "attachmentMetadata"?: Set<meta::v1::KeyValue>,
    "detachError"?: VolumeError,
  };
  type VolumeError = {
    "message"?: __cedar::String,
    "time"?: __cedar::String,
  };
  type VolumeNodeResources = {
    "count"?: __cedar::Long,
  };
  entity CSIDriver = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: CSIDriver,
    "spec": CSIDriverSpec,
  };
  entity CSINode = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: CSINode,
    "spec": CSINodeSpec,
  };
  entity CSIStorageCapacity = {
    "apiVersion"?: __cedar::String,
    "capacity"?: __cedar::String,
    "kind"?: __cedar::String,
    "maximumVolumeSize"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "nodeTopology"?: meta::v1::LabelSelector,
    "oldObject"?: CSIStorageCapacity,
    "storageClassName": __cedar::String,
  };
  entity StorageClass = {
    "allowVolumeExpansion"?: __cedar::Bool,
    "allowedTopologies"?: Set<core::v1::TopologySelectorTerm>,
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "mountOptions"?: Set<__cedar::String>,
    "oldObject"?: StorageClass,
    "parameters"?: Set<meta::v1::KeyValue>,
    "provisioner": __cedar::String,
    "reclaimPolicy"?: __cedar::String,
    "volumeBindingMode"?: __cedar::String,
  };
  entity VolumeAttachment = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: VolumeAttachment,
    "spec": VolumeAttachmentSpec,
    "status"?: VolumeAttachmentStatus,
  };
}
namespace aws::k8s::cedar::v1alpha1 {
  entity Policy = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: Policy,
    "spec": {
      "content"?: __cedar::String,
    },
  };
}
namespace flowcontrol::v1beta3 {
  type ExemptPriorityLevelConfiguration = {
    "lendablePercent"?: __cedar::Long,
    "nominalConcurrencyShares"?: __cedar::Long,
  };
  type FlowDistinguisherMethod = {
    "type": __cedar::String,
  };
  type FlowSchemaCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status"?: __cedar::String,
    "type"?: __cedar::String,
  };
  type FlowSchemaSpec = {
    "distinguisherMethod"?: FlowDistinguisherMethod,
    "matchingPrecedence"?: __cedar::Long,
    "priorityLevelConfiguration": PriorityLevelConfigurationReference,
    "rules"?: Set<PolicyRulesWithSubjects>,
  };
  type FlowSchemaStatus = {
    "conditions"?: Set<FlowSchemaCondition>,
  };
  type GroupSubject = {
    "name": __cedar::String,
  };
  type LimitResponse = {
    "queuing"?: QueuingConfiguration,
    "type": __cedar::String,
  };
  type LimitedPriorityLevelConfiguration = {
    "borrowingLimitPercent"?: __cedar::Long,
    "lendablePercent"?: __cedar::Long,
    "limitResponse"?: LimitResponse,
    "nominalConcurrencyShares"?: __cedar::Long,
  };
  type NonResourcePolicyRule = {
    "nonResourceURLs": Set<__cedar::String>,
    "verbs": Set<__cedar::String>,
  };
  type PolicyRulesWithSubjects = {
    "nonResourceRules"?: Set<NonResourcePolicyRule>,
    "resourceRules"?: Set<ResourcePolicyRule>,
    "subjects": Set<Subject>,
  };
  type PriorityLevelConfigurationCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status"?: __cedar::String,
    "type"?: __cedar::String,
  };
  type PriorityLevelConfigurationReference = {
    "name": __cedar::String,
  };
  type PriorityLevelConfigurationSpec = {
    "exempt"?: ExemptPriorityLevelConfiguration,
    "limited"?: LimitedPriorityLevelConfiguration,
    "type": __cedar::String,
  };
  type PriorityLevelConfigurationStatus = {
    "conditions"?: Set<PriorityLevelConfigurationCondition>,
  };
  type QueuingConfiguration = {
    "handSize"?: __cedar::Long,
    "queueLengthLimit"?: __cedar::Long,
    "queues"?: __cedar::Long,
  };
  type ResourcePolicyRule = {
    "apiGroups": Set<__cedar::String>,
    "clusterScope"?: __cedar::Bool,
    "namespaces"?: Set<__cedar::String>,
    "resources": Set<__cedar::String>,
    "verbs": Set<__cedar::String>,
  };
  type ServiceAccountSubject = {
    "name": __cedar::String,
    "namespace": __cedar::String,
  };
  type Subject = {
    "group"?: GroupSubject,
    "kind": __cedar::String,
    "serviceAccount"?: ServiceAccountSubject,
    "user"?: UserSubject,
  };
  type UserSubject = {
    "name": __cedar::String,
  };
  entity FlowSchema = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: FlowSchema,
    "spec"?: FlowSchemaSpec,
    "status"?: FlowSchemaStatus,
  };
  entity PriorityLevelConfiguration = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: PriorityLevelConfiguration,
    "spec"?: PriorityLevelConfigurationSpec,
    "status"?: PriorityLevelConfigurationStatus,
  };
}
namespace autoscaling::v2 {
  type ContainerResourceMetricSource = {
    "container": __cedar::String,
    "name": __cedar::String,
    "target": MetricTarget,
  };
  type ContainerResourceMetricStatus = {
    "container": __cedar::String,
    "current": MetricValueStatus,
    "name": __cedar::String,
  };
  type CrossVersionObjectReference = {
    "apiVersion"?: __cedar::String,
    "kind": __cedar::String,
    "name": __cedar::String,
  };
  type ExternalMetricSource = {
    "metric": MetricIdentifier,
    "target": MetricTarget,
  };
  type ExternalMetricStatus = {
    "current": MetricValueStatus,
    "metric": MetricIdentifier,
  };
  type HPAScalingPolicy = {
    "periodSeconds": __cedar::Long,
    "type": __cedar::String,
    "value": __cedar::Long,
  };
  type HPAScalingRules = {
    "policies"?: Set<HPAScalingPolicy>,
    "selectPolicy"?: __cedar::String,
    "stabilizationWindowSeconds"?: __cedar::Long,
  };
  type HorizontalPodAutoscalerBehavior = {
    "scaleDown"?: HPAScalingRules,
    "scaleUp"?: HPAScalingRules,
  };
  type HorizontalPodAutoscalerCondition = {
    "lastTransitionTime"?: __cedar::String,
    "message"?: __cedar::String,
    "reason"?: __cedar::String,
    "status": __cedar::String,
    "type": __cedar::String,
  };
  type HorizontalPodAutoscalerSpec = {
    "behavior"?: HorizontalPodAutoscalerBehavior,
    "maxReplicas": __cedar::Long,
    "metrics"?: Set<MetricSpec>,
    "minReplicas"?: __cedar::Long,
    "scaleTargetRef": CrossVersionObjectReference,
  };
  type HorizontalPodAutoscalerStatus = {
    "conditions"?: Set<HorizontalPodAutoscalerCondition>,
    "currentMetrics"?: Set<MetricStatus>,
    "currentReplicas"?: __cedar::Long,
    "desiredReplicas": __cedar::Long,
    "lastScaleTime"?: __cedar::String,
    "observedGeneration"?: __cedar::Long,
  };
  type MetricIdentifier = {
    "name": __cedar::String,
    "selector"?: meta::v1::LabelSelector,
  };
  type MetricSpec = {
    "containerResource"?: ContainerResourceMetricSource,
    "external"?: ExternalMetricSource,
    "object"?: ObjectMetricSource,
    "pods"?: PodsMetricSource,
    "resource"?: ResourceMetricSource,
    "type": __cedar::String,
  };
  type MetricStatus = {
    "containerResource"?: ContainerResourceMetricStatus,
    "external"?: ExternalMetricStatus,
    "object"?: ObjectMetricStatus,
    "pods"?: PodsMetricStatus,
    "resource"?: ResourceMetricStatus,
    "type": __cedar::String,
  };
  type MetricTarget = {
    "averageUtilization"?: __cedar::Long,
    "averageValue"?: __cedar::String,
    "type": __cedar::String,
    "value"?: __cedar::String,
  };
  type MetricValueStatus = {
    "averageUtilization"?: __cedar::Long,
    "averageValue"?: __cedar::String,
    "value"?: __cedar::String,
  };
  type ObjectMetricSource = {
    "describedObject": CrossVersionObjectReference,
    "metric": MetricIdentifier,
    "target": MetricTarget,
  };
  type ObjectMetricStatus = {
    "current": MetricValueStatus,
    "describedObject": CrossVersionObjectReference,
    "metric": MetricIdentifier,
  };
  type PodsMetricSource = {
    "metric": MetricIdentifier,
    "target": MetricTarget,
  };
  type PodsMetricStatus = {
    "current": MetricValueStatus,
    "metric": MetricIdentifier,
  };
  type ResourceMetricSource = {
    "name": __cedar::String,
    "target": MetricTarget,
  };
  type ResourceMetricStatus = {
    "current": MetricValueStatus,
    "name": __cedar::String,
  };
  entity HorizontalPodAutoscaler = {
    "apiVersion"?: __cedar::String,
    "kind"?: __cedar::String,
    "metadata"?: meta::v1::ObjectMeta,
    "oldObject"?: HorizontalPodAutoscaler,
    "spec"?: HorizontalPodAutoscalerSpec,
    "status"?: HorizontalPodAutoscalerStatus,
  };
}
